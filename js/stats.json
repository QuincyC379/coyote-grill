{
  "errors": [],
  "warnings": [],
  "version": "2.2.0-rc.7",
  "hash": "7891abdab52e94347027",
  "time": 155,
  "publicPath": "/js/",
  "assetsByChunkName": {
    "main": [
      "bundle.js",
      "bundle.js.map"
    ]
  },
  "assets": [
    {
      "name": "bundle.js",
      "size": 230301,
      "chunks": [
        0
      ],
      "chunkNames": [
        "main"
      ],
      "emitted": true
    },
    {
      "name": "bundle.js.map",
      "size": 279882,
      "chunks": [
        0
      ],
      "chunkNames": [
        "main"
      ],
      "emitted": true
    }
  ],
  "entrypoints": {
    "main": {
      "chunks": [
        0
      ],
      "assets": [
        "bundle.js",
        "bundle.js.map"
      ]
    }
  },
  "chunks": [
    {
      "id": 0,
      "rendered": true,
      "initial": true,
      "entry": true,
      "extraAsync": false,
      "size": 219693,
      "names": [
        "main"
      ],
      "files": [
        "bundle.js",
        "bundle.js.map"
      ],
      "hash": "424e9ed092a9ee5381ed",
      "parents": [],
      "origins": [
        {
          "moduleId": 38,
          "module": "multi preact/devtools ./_js/main.js",
          "moduleIdentifier": "multi preact/devtools ./_js/main.js",
          "moduleName": "multi preact/devtools ./_js/main.js",
          "loc": "",
          "name": "main",
          "reasons": []
        }
      ]
    }
  ],
  "modules": [
    {
      "id": 0,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/fizzy-ui-utils/utils.js",
      "name": "./~/fizzy-ui-utils/utils.js",
      "index": 24,
      "index2": 20,
      "size": 5873,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-16:6"
        },
        {
          "moduleId": 22,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/add-remove-cell.js",
          "module": "./~/flickity/js/add-remove-cell.js",
          "moduleName": "./~/flickity/js/add-remove-cell.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-12:6"
        },
        {
          "moduleId": 23,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/animate.js",
          "module": "./~/flickity/js/animate.js",
          "moduleName": "./~/flickity/js/animate.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-11:6"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/drag.js",
          "module": "./~/flickity/js/drag.js",
          "moduleName": "./~/flickity/js/drag.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 27,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/lazyload.js",
          "module": "./~/flickity/js/lazyload.js",
          "moduleName": "./~/flickity/js/lazyload.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-12:6"
        },
        {
          "moduleId": 28,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/page-dots.js",
          "module": "./~/flickity/js/page-dots.js",
          "moduleName": "./~/flickity/js/page-dots.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 29,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/player.js",
          "module": "./~/flickity/js/player.js",
          "moduleName": "./~/flickity/js/player.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 30,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/prev-next-button.js",
          "module": "./~/flickity/js/prev-next-button.js",
          "moduleName": "./~/flickity/js/prev-next-button.js",
          "type": "amd require",
          "userRequest": "fizzy-ui-utils/utils",
          "loc": "7:4-13:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/**\n * Fizzy UI utils v2.0.3\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'desandro-matches-selector/matches-selector'\n    ], function( matchesSelector ) {\n      return factory( window, matchesSelector );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('desandro-matches-selector')\n    );\n  } else {\n    // browser global\n    window.fizzyUIUtils = factory(\n      window,\n      window.matchesSelector\n    );\n  }\n\n}( window, function factory( window, matchesSelector ) {\n\n'use strict';\n\nvar utils = {};\n\n// ----- extend ----- //\n\n// extends objects\nutils.extend = function( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n};\n\n// ----- modulo ----- //\n\nutils.modulo = function( num, div ) {\n  return ( ( num % div ) + div ) % div;\n};\n\n// ----- makeArray ----- //\n\n// turn element or nodeList into an array\nutils.makeArray = function( obj ) {\n  var ary = [];\n  if ( Array.isArray( obj ) ) {\n    // use object if already an array\n    ary = obj;\n  } else if ( obj && typeof obj.length == 'number' ) {\n    // convert nodeList to array\n    for ( var i=0; i < obj.length; i++ ) {\n      ary.push( obj[i] );\n    }\n  } else {\n    // array of single index\n    ary.push( obj );\n  }\n  return ary;\n};\n\n// ----- removeFrom ----- //\n\nutils.removeFrom = function( ary, obj ) {\n  var index = ary.indexOf( obj );\n  if ( index != -1 ) {\n    ary.splice( index, 1 );\n  }\n};\n\n// ----- getParent ----- //\n\nutils.getParent = function( elem, selector ) {\n  while ( elem != document.body ) {\n    elem = elem.parentNode;\n    if ( matchesSelector( elem, selector ) ) {\n      return elem;\n    }\n  }\n};\n\n// ----- getQueryElement ----- //\n\n// use element as selector string\nutils.getQueryElement = function( elem ) {\n  if ( typeof elem == 'string' ) {\n    return document.querySelector( elem );\n  }\n  return elem;\n};\n\n// ----- handleEvent ----- //\n\n// enable .ontype to trigger from .addEventListener( elem, 'type' )\nutils.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// ----- filterFindElements ----- //\n\nutils.filterFindElements = function( elems, selector ) {\n  // make array of elems\n  elems = utils.makeArray( elems );\n  var ffElems = [];\n\n  elems.forEach( function( elem ) {\n    // check that elem is an actual element\n    if ( !( elem instanceof HTMLElement ) ) {\n      return;\n    }\n    // add elem if no selector\n    if ( !selector ) {\n      ffElems.push( elem );\n      return;\n    }\n    // filter & find items if we have a selector\n    // filter\n    if ( matchesSelector( elem, selector ) ) {\n      ffElems.push( elem );\n    }\n    // find children\n    var childElems = elem.querySelectorAll( selector );\n    // concat childElems to filterFound array\n    for ( var i=0; i < childElems.length; i++ ) {\n      ffElems.push( childElems[i] );\n    }\n  });\n\n  return ffElems;\n};\n\n// ----- debounceMethod ----- //\n\nutils.debounceMethod = function( _class, methodName, threshold ) {\n  // original method\n  var method = _class.prototype[ methodName ];\n  var timeoutName = methodName + 'Timeout';\n\n  _class.prototype[ methodName ] = function() {\n    var timeout = this[ timeoutName ];\n    if ( timeout ) {\n      clearTimeout( timeout );\n    }\n    var args = arguments;\n\n    var _this = this;\n    this[ timeoutName ] = setTimeout( function() {\n      method.apply( _this, args );\n      delete _this[ timeoutName ];\n    }, threshold || 100 );\n  };\n};\n\n// ----- docReady ----- //\n\nutils.docReady = function( callback ) {\n  var readyState = document.readyState;\n  if ( readyState == 'complete' || readyState == 'interactive' ) {\n    // do async to allow for other scripts to run. metafizzy/flickity#441\n    setTimeout( callback );\n  } else {\n    document.addEventListener( 'DOMContentLoaded', callback );\n  }\n};\n\n// ----- htmlInit ----- //\n\n// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\nutils.toDashed = function( str ) {\n  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {\n    return $1 + '-' + $2;\n  }).toLowerCase();\n};\n\nvar console = window.console;\n/**\n * allow user to initialize classes via [data-namespace] or .js-namespace class\n * htmlInit( Widget, 'widgetName' )\n * options are parsed from data-namespace-options\n */\nutils.htmlInit = function( WidgetClass, namespace ) {\n  utils.docReady( function() {\n    var dashedNamespace = utils.toDashed( namespace );\n    var dataAttr = 'data-' + dashedNamespace;\n    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );\n    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );\n    var elems = utils.makeArray( dataAttrElems )\n      .concat( utils.makeArray( jsDashElems ) );\n    var dataOptionsAttr = dataAttr + '-options';\n    var jQuery = window.jQuery;\n\n    elems.forEach( function( elem ) {\n      var attr = elem.getAttribute( dataAttr ) ||\n        elem.getAttribute( dataOptionsAttr );\n      var options;\n      try {\n        options = attr && JSON.parse( attr );\n      } catch ( error ) {\n        // log error, do not initialize\n        if ( console ) {\n          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +\n          ': ' + error );\n        }\n        return;\n      }\n      // initialize\n      var instance = new WidgetClass( elem, options );\n      // make available via $().data('namespace')\n      if ( jQuery ) {\n        jQuery.data( elem, namespace, instance );\n      }\n    });\n\n  });\n};\n\n// -----  ----- //\n\nreturn utils;\n\n}));\n"
    },
    {
      "id": 1,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "name": "./~/flickity/js/flickity.js",
      "index": 21,
      "index2": 24,
      "size": 22546,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 22,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/add-remove-cell.js",
          "module": "./~/flickity/js/add-remove-cell.js",
          "moduleName": "./~/flickity/js/add-remove-cell.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-12:6"
        },
        {
          "moduleId": 25,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/drag.js",
          "module": "./~/flickity/js/drag.js",
          "moduleName": "./~/flickity/js/drag.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "17:4-25:16"
        },
        {
          "moduleId": 27,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/lazyload.js",
          "module": "./~/flickity/js/lazyload.js",
          "moduleName": "./~/flickity/js/lazyload.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-12:6"
        },
        {
          "moduleId": 28,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/page-dots.js",
          "module": "./~/flickity/js/page-dots.js",
          "moduleName": "./~/flickity/js/page-dots.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 29,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/player.js",
          "module": "./~/flickity/js/player.js",
          "moduleName": "./~/flickity/js/player.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 30,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/prev-next-button.js",
          "module": "./~/flickity/js/prev-next-button.js",
          "moduleName": "./~/flickity/js/prev-next-button.js",
          "type": "amd require",
          "userRequest": "./flickity",
          "loc": "7:4-13:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// Flickity main\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'ev-emitter/ev-emitter',\n      'get-size/get-size',\n      'fizzy-ui-utils/utils',\n      './cell',\n      './slide',\n      './animate'\n    ], function( EvEmitter, getSize, utils, Cell, Slide, animatePrototype ) {\n      return factory( window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('ev-emitter'),\n      require('get-size'),\n      require('fizzy-ui-utils'),\n      require('./cell'),\n      require('./slide'),\n      require('./animate')\n    );\n  } else {\n    // browser global\n    var _Flickity = window.Flickity;\n\n    window.Flickity = factory(\n      window,\n      window.EvEmitter,\n      window.getSize,\n      window.fizzyUIUtils,\n      _Flickity.Cell,\n      _Flickity.Slide,\n      _Flickity.animatePrototype\n    );\n  }\n\n}( window, function factory( window, EvEmitter, getSize,\n  utils, Cell, Slide, animatePrototype ) {\n\n'use strict';\n\n// vars\nvar jQuery = window.jQuery;\nvar getComputedStyle = window.getComputedStyle;\nvar console = window.console;\n\nfunction moveElements( elems, toElem ) {\n  elems = utils.makeArray( elems );\n  while ( elems.length ) {\n    toElem.appendChild( elems.shift() );\n  }\n}\n\n// -------------------------- Flickity -------------------------- //\n\n// globally unique identifiers\nvar GUID = 0;\n// internal store of all Flickity intances\nvar instances = {};\n\nfunction Flickity( element, options ) {\n  var queryElement = utils.getQueryElement( element );\n  if ( !queryElement ) {\n    if ( console ) {\n      console.error( 'Bad element for Flickity: ' + ( queryElement || element ) );\n    }\n    return;\n  }\n  this.element = queryElement;\n  // do not initialize twice on same element\n  if ( this.element.flickityGUID ) {\n    var instance = instances[ this.element.flickityGUID ];\n    instance.option( options );\n    return instance;\n  }\n\n  // add jQuery\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n  // options\n  this.options = utils.extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  // kick things off\n  this._create();\n}\n\nFlickity.defaults = {\n  accessibility: true,\n  // adaptiveHeight: false,\n  cellAlign: 'center',\n  // cellSelector: undefined,\n  // contain: false,\n  freeScrollFriction: 0.075, // friction when free-scrolling\n  friction: 0.28, // friction when selecting\n  namespaceJQueryEvents: true,\n  // initialIndex: 0,\n  percentPosition: true,\n  resize: true,\n  selectedAttraction: 0.025,\n  setGallerySize: true\n  // watchCSS: false,\n  // wrapAround: false\n};\n\n// hash of methods triggered on _create()\nFlickity.createMethods = [];\n\nvar proto = Flickity.prototype;\n// inherit EventEmitter\nutils.extend( proto, EvEmitter.prototype );\n\nproto._create = function() {\n  // add id for Flickity.data\n  var id = this.guid = ++GUID;\n  this.element.flickityGUID = id; // expando\n  instances[ id ] = this; // associate via id\n  // initial properties\n  this.selectedIndex = 0;\n  // how many frames slider has been in same position\n  this.restingFrames = 0;\n  // initial physics properties\n  this.x = 0;\n  this.velocity = 0;\n  this.originSide = this.options.rightToLeft ? 'right' : 'left';\n  // create viewport & slider\n  this.viewport = document.createElement('div');\n  this.viewport.className = 'flickity-viewport';\n  this._createSlider();\n\n  if ( this.options.resize || this.options.watchCSS ) {\n    window.addEventListener( 'resize', this );\n  }\n\n  Flickity.createMethods.forEach( function( method ) {\n    this[ method ]();\n  }, this );\n\n  if ( this.options.watchCSS ) {\n    this.watchCSS();\n  } else {\n    this.activate();\n  }\n\n};\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  utils.extend( this.options, opts );\n};\n\nproto.activate = function() {\n  if ( this.isActive ) {\n    return;\n  }\n  this.isActive = true;\n  this.element.classList.add('flickity-enabled');\n  if ( this.options.rightToLeft ) {\n    this.element.classList.add('flickity-rtl');\n  }\n\n  this.getSize();\n  // move initial cell elements so they can be loaded as cells\n  var cellElems = this._filterFindCellElements( this.element.children );\n  moveElements( cellElems, this.slider );\n  this.viewport.appendChild( this.slider );\n  this.element.appendChild( this.viewport );\n  // get cells from children\n  this.reloadCells();\n\n  if ( this.options.accessibility ) {\n    // allow element to focusable\n    this.element.tabIndex = 0;\n    // listen for key presses\n    this.element.addEventListener( 'keydown', this );\n  }\n\n  this.emitEvent('activate');\n\n  var index;\n  var initialIndex = this.options.initialIndex;\n  if ( this.isInitActivated ) {\n    index = this.selectedIndex;\n  } else if ( initialIndex !== undefined ) {\n    index = this.cells[ initialIndex ] ? initialIndex : 0;\n  } else {\n    index = 0;\n  }\n  // select instantly\n  this.select( index, false, true );\n  // flag for initial activation, for using initialIndex\n  this.isInitActivated = true;\n};\n\n// slider positions the cells\nproto._createSlider = function() {\n  // slider element does all the positioning\n  var slider = document.createElement('div');\n  slider.className = 'flickity-slider';\n  slider.style[ this.originSide ] = 0;\n  this.slider = slider;\n};\n\nproto._filterFindCellElements = function( elems ) {\n  return utils.filterFindElements( elems, this.options.cellSelector );\n};\n\n// goes through all children\nproto.reloadCells = function() {\n  // collection of item elements\n  this.cells = this._makeCells( this.slider.children );\n  this.positionCells();\n  this._getWrapShiftCells();\n  this.setGallerySize();\n};\n\n/**\n * turn elements into Flickity.Cells\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Flickity Cells\n */\nproto._makeCells = function( elems ) {\n  var cellElems = this._filterFindCellElements( elems );\n\n  // create new Flickity for collection\n  var cells = cellElems.map( function( cellElem ) {\n    return new Cell( cellElem, this );\n  }, this );\n\n  return cells;\n};\n\nproto.getLastCell = function() {\n  return this.cells[ this.cells.length - 1 ];\n};\n\nproto.getLastSlide = function() {\n  return this.slides[ this.slides.length - 1 ];\n};\n\n// positions all cells\nproto.positionCells = function() {\n  // size all cells\n  this._sizeCells( this.cells );\n  // position all cells\n  this._positionCells( 0 );\n};\n\n/**\n * position certain cells\n * @param {Integer} index - which cell to start with\n */\nproto._positionCells = function( index ) {\n  index = index || 0;\n  // also measure maxCellHeight\n  // start 0 if positioning all cells\n  this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\n  var cellX = 0;\n  // get cellX\n  if ( index > 0 ) {\n    var startCell = this.cells[ index - 1 ];\n    cellX = startCell.x + startCell.size.outerWidth;\n  }\n  var len = this.cells.length;\n  for ( var i=index; i < len; i++ ) {\n    var cell = this.cells[i];\n    cell.setPosition( cellX );\n    cellX += cell.size.outerWidth;\n    this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );\n  }\n  // keep track of cellX for wrap-around\n  this.slideableWidth = cellX;\n  // slides\n  this.updateSlides();\n  // contain slides target\n  this._containSlides();\n  // update slidesWidth\n  this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;\n};\n\n/**\n * cell.getSize() on multiple cells\n * @param {Array} cells\n */\nproto._sizeCells = function( cells ) {\n  cells.forEach( function( cell ) {\n    cell.getSize();\n  });\n};\n\n// --------------------------  -------------------------- //\n\nproto.updateSlides = function() {\n  this.slides = [];\n  if ( !this.cells.length ) {\n    return;\n  }\n\n  var slide = new Slide( this );\n  this.slides.push( slide );\n  var isOriginLeft = this.originSide == 'left';\n  var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';\n\n  var canCellFit = this._getCanCellFit();\n\n  this.cells.forEach( function( cell, i ) {\n    // just add cell if first cell in slide\n    if ( !slide.cells.length ) {\n      slide.addCell( cell );\n      return;\n    }\n\n    var slideWidth = ( slide.outerWidth - slide.firstMargin ) +\n      ( cell.size.outerWidth - cell.size[ nextMargin ] );\n\n    if ( canCellFit.call( this, i, slideWidth ) ) {\n      slide.addCell( cell );\n    } else {\n      // doesn't fit, new slide\n      slide.updateTarget();\n\n      slide = new Slide( this );\n      this.slides.push( slide );\n      slide.addCell( cell );\n    }\n  }, this );\n  // last slide\n  slide.updateTarget();\n  // update .selectedSlide\n  this.updateSelectedSlide();\n};\n\nproto._getCanCellFit = function() {\n  var groupCells = this.options.groupCells;\n  if ( !groupCells ) {\n    return function() {\n      return false;\n    };\n  } else if ( typeof groupCells == 'number' ) {\n    // group by number. 3 -> [0,1,2], [3,4,5], ...\n    var number = parseInt( groupCells, 10 );\n    return function( i ) {\n      return ( i % number ) !== 0;\n    };\n  }\n  // default, group by width of slide\n  // parse '75%\n  var percentMatch = typeof groupCells == 'string' &&\n    groupCells.match(/^(\\d+)%$/);\n  var percent = percentMatch ? parseInt( percentMatch[1], 10 ) / 100 : 1;\n  return function( i, slideWidth ) {\n    return slideWidth <= ( this.size.innerWidth + 1 ) * percent;\n  };\n};\n\n// alias _init for jQuery plugin .flickity()\nproto._init =\nproto.reposition = function() {\n  this.positionCells();\n  this.positionSliderAtSelected();\n};\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n  this.setCellAlign();\n  this.cursorPosition = this.size.innerWidth * this.cellAlign;\n};\n\nvar cellAlignShorthands = {\n  // cell align, then based on origin side\n  center: {\n    left: 0.5,\n    right: 0.5\n  },\n  left: {\n    left: 0,\n    right: 1\n  },\n  right: {\n    right: 0,\n    left: 1\n  }\n};\n\nproto.setCellAlign = function() {\n  var shorthand = cellAlignShorthands[ this.options.cellAlign ];\n  this.cellAlign = shorthand ? shorthand[ this.originSide ] : this.options.cellAlign;\n};\n\nproto.setGallerySize = function() {\n  if ( this.options.setGallerySize ) {\n    var height = this.options.adaptiveHeight && this.selectedSlide ?\n      this.selectedSlide.height : this.maxCellHeight;\n    this.viewport.style.height = height + 'px';\n  }\n};\n\nproto._getWrapShiftCells = function() {\n  // only for wrap-around\n  if ( !this.options.wrapAround ) {\n    return;\n  }\n  // unshift previous cells\n  this._unshiftCells( this.beforeShiftCells );\n  this._unshiftCells( this.afterShiftCells );\n  // get before cells\n  // initial gap\n  var gapX = this.cursorPosition;\n  var cellIndex = this.cells.length - 1;\n  this.beforeShiftCells = this._getGapCells( gapX, cellIndex, -1 );\n  // get after cells\n  // ending gap between last cell and end of gallery viewport\n  gapX = this.size.innerWidth - this.cursorPosition;\n  // start cloning at first cell, working forwards\n  this.afterShiftCells = this._getGapCells( gapX, 0, 1 );\n};\n\nproto._getGapCells = function( gapX, cellIndex, increment ) {\n  // keep adding cells until the cover the initial gap\n  var cells = [];\n  while ( gapX > 0 ) {\n    var cell = this.cells[ cellIndex ];\n    if ( !cell ) {\n      break;\n    }\n    cells.push( cell );\n    cellIndex += increment;\n    gapX -= cell.size.outerWidth;\n  }\n  return cells;\n};\n\n// ----- contain ----- //\n\n// contain cell targets so no excess sliding\nproto._containSlides = function() {\n  if ( !this.options.contain || this.options.wrapAround || !this.cells.length ) {\n    return;\n  }\n  var isRightToLeft = this.options.rightToLeft;\n  var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';\n  var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';\n  var contentWidth = this.slideableWidth - this.getLastCell().size[ endMargin ];\n  // content is less than gallery size\n  var isContentSmaller = contentWidth < this.size.innerWidth;\n  // bounds\n  var beginBound = this.cursorPosition + this.cells[0].size[ beginMargin ];\n  var endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );\n  // contain each cell target\n  this.slides.forEach( function( slide ) {\n    if ( isContentSmaller ) {\n      // all cells fit inside gallery\n      slide.target = contentWidth * this.cellAlign;\n    } else {\n      // contain to bounds\n      slide.target = Math.max( slide.target, beginBound );\n      slide.target = Math.min( slide.target, endBound );\n    }\n  }, this );\n};\n\n// -----  ----- //\n\n/**\n * emits events via eventEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  var emitArgs = event ? [ event ].concat( args ) : args;\n  this.emitEvent( type, emitArgs );\n\n  if ( jQuery && this.$element ) {\n    // default trigger with type if no event\n    type += this.options.namespaceJQueryEvents ? '.flickity' : '';\n    var $event = type;\n    if ( event ) {\n      // create jQuery event\n      var jQEvent = jQuery.Event( event );\n      jQEvent.type = type;\n      $event = jQEvent;\n    }\n    this.$element.trigger( $event, args );\n  }\n};\n\n// -------------------------- select -------------------------- //\n\n/**\n * @param {Integer} index - index of the slide\n * @param {Boolean} isWrap - will wrap-around to last/first if at the end\n * @param {Boolean} isInstant - will immediately set position at selected cell\n */\nproto.select = function( index, isWrap, isInstant ) {\n  if ( !this.isActive ) {\n    return;\n  }\n  index = parseInt( index, 10 );\n  this._wrapSelect( index );\n\n  if ( this.options.wrapAround || isWrap ) {\n    index = utils.modulo( index, this.slides.length );\n  }\n  // bail if invalid index\n  if ( !this.slides[ index ] ) {\n    return;\n  }\n  this.selectedIndex = index;\n  this.updateSelectedSlide();\n  if ( isInstant ) {\n    this.positionSliderAtSelected();\n  } else {\n    this.startAnimation();\n  }\n  if ( this.options.adaptiveHeight ) {\n    this.setGallerySize();\n  }\n\n  this.dispatchEvent('select');\n  // old v1 event name, remove in v3\n  this.dispatchEvent('cellSelect');\n};\n\n// wraps position for wrapAround, to move to closest slide. #113\nproto._wrapSelect = function( index ) {\n  var len = this.slides.length;\n  var isWrapping = this.options.wrapAround && len > 1;\n  if ( !isWrapping ) {\n    return index;\n  }\n  var wrapIndex = utils.modulo( index, len );\n  // go to shortest\n  var delta = Math.abs( wrapIndex - this.selectedIndex );\n  var backWrapDelta = Math.abs( ( wrapIndex + len ) - this.selectedIndex );\n  var forewardWrapDelta = Math.abs( ( wrapIndex - len ) - this.selectedIndex );\n  if ( !this.isDragSelect && backWrapDelta < delta ) {\n    index += len;\n  } else if ( !this.isDragSelect && forewardWrapDelta < delta ) {\n    index -= len;\n  }\n  // wrap position so slider is within normal area\n  if ( index < 0 ) {\n    this.x -= this.slideableWidth;\n  } else if ( index >= len ) {\n    this.x += this.slideableWidth;\n  }\n};\n\nproto.previous = function( isWrap, isInstant ) {\n  this.select( this.selectedIndex - 1, isWrap, isInstant );\n};\n\nproto.next = function( isWrap, isInstant ) {\n  this.select( this.selectedIndex + 1, isWrap, isInstant );\n};\n\nproto.updateSelectedSlide = function() {\n  var slide = this.slides[ this.selectedIndex ];\n  // selectedIndex could be outside of slides, if triggered before resize()\n  if ( !slide ) {\n    return;\n  }\n  // unselect previous selected slide\n  this.unselectSelectedSlide();\n  // update new selected slide\n  this.selectedSlide = slide;\n  slide.select();\n  this.selectedCells = slide.cells;\n  this.selectedElements = slide.getCellElements();\n  // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\n  // Remove in v3?\n  this.selectedCell = slide.cells[0];\n  this.selectedElement = this.selectedElements[0];\n};\n\nproto.unselectSelectedSlide = function() {\n  if ( this.selectedSlide ) {\n    this.selectedSlide.unselect();\n  }\n};\n\n/**\n * select slide from number or cell element\n * @param {Element or Number} elem\n */\nproto.selectCell = function( value, isWrap, isInstant ) {\n  // get cell\n  var cell;\n  if ( typeof value == 'number' ) {\n    cell = this.cells[ value ];\n  } else {\n    // use string as selector\n    if ( typeof value == 'string' ) {\n      value = this.element.querySelector( value );\n    }\n    // get cell from element\n    cell = this.getCell( value );\n  }\n  // select slide that has cell\n  for ( var i=0; cell && i < this.slides.length; i++ ) {\n    var slide = this.slides[i];\n    var index = slide.cells.indexOf( cell );\n    if ( index != -1 ) {\n      this.select( i, isWrap, isInstant );\n      return;\n    }\n  }\n};\n\n// -------------------------- get cells -------------------------- //\n\n/**\n * get Flickity.Cell, given an Element\n * @param {Element} elem\n * @returns {Flickity.Cell} item\n */\nproto.getCell = function( elem ) {\n  // loop through cells to get the one that matches\n  for ( var i=0; i < this.cells.length; i++ ) {\n    var cell = this.cells[i];\n    if ( cell.element == elem ) {\n      return cell;\n    }\n  }\n};\n\n/**\n * get collection of Flickity.Cells, given Elements\n * @param {Element, Array, NodeList} elems\n * @returns {Array} cells - Flickity.Cells\n */\nproto.getCells = function( elems ) {\n  elems = utils.makeArray( elems );\n  var cells = [];\n  elems.forEach( function( elem ) {\n    var cell = this.getCell( elem );\n    if ( cell ) {\n      cells.push( cell );\n    }\n  }, this );\n  return cells;\n};\n\n/**\n * get cell elements\n * @returns {Array} cellElems\n */\nproto.getCellElements = function() {\n  return this.cells.map( function( cell ) {\n    return cell.element;\n  });\n};\n\n/**\n * get parent cell from an element\n * @param {Element} elem\n * @returns {Flickit.Cell} cell\n */\nproto.getParentCell = function( elem ) {\n  // first check if elem is cell\n  var cell = this.getCell( elem );\n  if ( cell ) {\n    return cell;\n  }\n  // try to get parent cell elem\n  elem = utils.getParent( elem, '.flickity-slider > *' );\n  return this.getCell( elem );\n};\n\n/**\n * get cells adjacent to a slide\n * @param {Integer} adjCount - number of adjacent slides\n * @param {Integer} index - index of slide to start\n * @returns {Array} cells - array of Flickity.Cells\n */\nproto.getAdjacentCellElements = function( adjCount, index ) {\n  if ( !adjCount ) {\n    return this.selectedSlide.getCellElements();\n  }\n  index = index === undefined ? this.selectedIndex : index;\n\n  var len = this.slides.length;\n  if ( 1 + ( adjCount * 2 ) >= len ) {\n    return this.getCellElements();\n  }\n\n  var cellElems = [];\n  for ( var i = index - adjCount; i <= index + adjCount ; i++ ) {\n    var slideIndex = this.options.wrapAround ? utils.modulo( i, len ) : i;\n    var slide = this.slides[ slideIndex ];\n    if ( slide ) {\n      cellElems = cellElems.concat( slide.getCellElements() );\n    }\n  }\n  return cellElems;\n};\n\n// -------------------------- events -------------------------- //\n\nproto.uiChange = function() {\n  this.emitEvent('uiChange');\n};\n\nproto.childUIPointerDown = function( event ) {\n  this.emitEvent( 'childUIPointerDown', [ event ] );\n};\n\n// ----- resize ----- //\n\nproto.onresize = function() {\n  this.watchCSS();\n  this.resize();\n};\n\nutils.debounceMethod( Flickity, 'onresize', 150 );\n\nproto.resize = function() {\n  if ( !this.isActive ) {\n    return;\n  }\n  this.getSize();\n  // wrap values\n  if ( this.options.wrapAround ) {\n    this.x = utils.modulo( this.x, this.slideableWidth );\n  }\n  this.positionCells();\n  this._getWrapShiftCells();\n  this.setGallerySize();\n  this.emitEvent('resize');\n  // update selected index for group slides, instant\n  // TODO: position can be lost between groups of various numbers\n  var selectedElement = this.selectedElements && this.selectedElements[0];\n  this.selectCell( selectedElement, false, true );\n};\n\n// watches the :after property, activates/deactivates\nproto.watchCSS = function() {\n  var watchOption = this.options.watchCSS;\n  if ( !watchOption ) {\n    return;\n  }\n\n  var afterContent = getComputedStyle( this.element, ':after' ).content;\n  // activate if :after { content: 'flickity' }\n  if ( afterContent.indexOf('flickity') != -1 ) {\n    this.activate();\n  } else {\n    this.deactivate();\n  }\n};\n\n// ----- keydown ----- //\n\n// go previous/next if left/right keys pressed\nproto.onkeydown = function( event ) {\n  // only work if element is in focus\n  if ( !this.options.accessibility ||\n    ( document.activeElement && document.activeElement != this.element ) ) {\n    return;\n  }\n\n  if ( event.keyCode == 37 ) {\n    // go left\n    var leftMethod = this.options.rightToLeft ? 'next' : 'previous';\n    this.uiChange();\n    this[ leftMethod ]();\n  } else if ( event.keyCode == 39 ) {\n    // go right\n    var rightMethod = this.options.rightToLeft ? 'previous' : 'next';\n    this.uiChange();\n    this[ rightMethod ]();\n  }\n};\n\n// -------------------------- destroy -------------------------- //\n\n// deactivate all Flickity functionality, but keep stuff available\nproto.deactivate = function() {\n  if ( !this.isActive ) {\n    return;\n  }\n  this.element.classList.remove('flickity-enabled');\n  this.element.classList.remove('flickity-rtl');\n  // destroy cells\n  this.cells.forEach( function( cell ) {\n    cell.destroy();\n  });\n  this.unselectSelectedSlide();\n  this.element.removeChild( this.viewport );\n  // move child elements back into element\n  moveElements( this.slider.children, this.element );\n  if ( this.options.accessibility ) {\n    this.element.removeAttribute('tabIndex');\n    this.element.removeEventListener( 'keydown', this );\n  }\n  // set flags\n  this.isActive = false;\n  this.emitEvent('deactivate');\n};\n\nproto.destroy = function() {\n  this.deactivate();\n  window.removeEventListener( 'resize', this );\n  this.emitEvent('destroy');\n  if ( jQuery && this.$element ) {\n    jQuery.removeData( this.element, 'flickity' );\n  }\n  delete this.element.flickityGUID;\n  delete instances[ this.guid ];\n};\n\n// -------------------------- prototype -------------------------- //\n\nutils.extend( proto, animatePrototype );\n\n// -------------------------- extras -------------------------- //\n\n/**\n * get Flickity instance from element\n * @param {Element} elem\n * @returns {Flickity}\n */\nFlickity.data = function( elem ) {\n  elem = utils.getQueryElement( elem );\n  var id = elem && elem.flickityGUID;\n  return id && instances[ id ];\n};\n\nutils.htmlInit( Flickity, 'flickity' );\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'flickity', Flickity );\n}\n\nFlickity.Cell = Cell;\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 2,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/ev-emitter/ev-emitter.js",
      "name": "./~/ev-emitter/ev-emitter.js",
      "index": 22,
      "index2": 17,
      "size": 2596,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "ev-emitter/ev-emitter",
          "loc": "7:4-16:6"
        },
        {
          "moduleId": 8,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/unipointer/unipointer.js",
          "module": "./~/unipointer/unipointer.js",
          "moduleName": "./~/unipointer/unipointer.js",
          "type": "amd require",
          "userRequest": "ev-emitter/ev-emitter",
          "loc": "14:4-18:6"
        },
        {
          "moduleId": 29,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/player.js",
          "module": "./~/flickity/js/player.js",
          "moduleName": "./~/flickity/js/player.js",
          "type": "amd require",
          "userRequest": "ev-emitter/ev-emitter",
          "loc": "7:4-13:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/**\n * EvEmitter v1.0.3\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD - RequireJS\n    define( factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS - Browserify, Webpack\n    module.exports = factory();\n  } else {\n    // Browser globals\n    global.EvEmitter = factory();\n  }\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var i = 0;\n  var listener = listeners[i];\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  while ( listener ) {\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n    // get next listener\n    i += isOnce ? 0 : 1;\n    listener = listeners[i];\n  }\n\n  return this;\n};\n\nreturn EvEmitter;\n\n}));\n"
    },
    {
      "id": 3,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/preact/devtools.js",
      "name": "./~/preact/devtools.js",
      "index": 1,
      "index2": 1,
      "size": 16757,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "multi preact/devtools ./_js/main.js",
      "issuerId": 38,
      "issuerName": "multi preact/devtools ./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 38,
          "moduleIdentifier": "multi preact/devtools ./_js/main.js",
          "module": "multi preact/devtools ./_js/main.js",
          "moduleName": "multi preact/devtools ./_js/main.js",
          "type": "single entry",
          "userRequest": "preact/devtools",
          "loc": "main:100000"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 1,
      "source": "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('preact')) :\n  typeof define === 'function' && define.amd ? define(['preact'], factory) :\n  (factory(global.preact));\n}(this, function (preact) { 'use strict';\n\n  var babelHelpers = {};\n\n  babelHelpers.inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  babelHelpers.classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  var ATTR_KEY = typeof Symbol !== 'undefined' ? Symbol['for']('preactattr') : '__preactattr_';\n\n  /** @private is the given object a Function? */\n\n  function isFunction(obj) {\n  \treturn 'function' === typeof obj;\n  }\n\n  /** Check if a VNode is a reference to a stateless functional component.\n   *\tA function component is represented as a VNode whose `nodeName` property is a reference to a function.\n   *\tIf that function is not a Component (ie, has no `.render()` method on a prototype), it is considered a stateless functional component.\n   *\t@param {VNode} vnode\tA VNode\n   *\t@private\n   */\n\n  function isFunctionalComponent(vnode) {\n    var nodeName = vnode && vnode.nodeName;\n    return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n  }\n\n  /**\n   * Return a ReactElement-compatible object for the current state of a preact\n   * component.\n   */\n  function createReactElement(component) {\n  \treturn {\n  \t\ttype: component.constructor,\n  \t\tkey: component.key,\n  \t\tref: null, // Unsupported\n  \t\tprops: component.props\n  \t};\n  }\n\n  /**\n   * Create a ReactDOMComponent-compatible object for a given DOM node rendered\n   * by preact.\n   *\n   * This implements the subset of the ReactDOMComponent interface that\n   * React DevTools requires in order to display DOM nodes in the inspector with\n   * the correct type and properties.\n   *\n   * @param {Node} node\n   */\n  function createReactDOMComponent(node) {\n  \tvar childNodes = node.nodeType === Node.ELEMENT_NODE ? Array.from(node.childNodes) : [];\n\n  \tvar isText = node.nodeType === Node.TEXT_NODE;\n\n  \treturn {\n  \t\t// --- ReactDOMComponent interface\n  \t\t_currentElement: isText ? node.textContent : {\n  \t\t\ttype: node.nodeName.toLowerCase(),\n  \t\t\tprops: node[ATTR_KEY]\n  \t\t},\n  \t\t_renderedChildren: childNodes.map(function (child) {\n  \t\t\tif (child._component) {\n  \t\t\t\treturn updateReactComponent(child._component);\n  \t\t\t}\n  \t\t\treturn updateReactComponent(child);\n  \t\t}),\n  \t\t_stringText: isText ? node.textContent : null,\n\n  \t\t// --- Additional properties used by preact devtools\n\n  \t\t// A flag indicating whether the devtools have been notified about the\n  \t\t// existence of this component instance yet.\n  \t\t// This is used to send the appropriate notifications when DOM components\n  \t\t// are added or updated between composite component updates.\n  \t\t_inDevTools: false,\n  \t\tnode: node\n  \t};\n  }\n\n  /**\n   * Return the name of a component created by a `ReactElement`-like object.\n   *\n   * @param {ReactElement} element\n   */\n  function typeName(element) {\n  \tif (typeof element.type === 'function') {\n  \t\treturn element.type.displayName || element.type.name;\n  \t}\n  \treturn element.type;\n  }\n\n  /**\n   * Return a ReactCompositeComponent-compatible object for a given preact\n   * component instance.\n   *\n   * This implements the subset of the ReactCompositeComponent interface that\n   * the DevTools requires in order to walk the component tree and inspect the\n   * component's properties.\n   *\n   * See https://github.com/facebook/react-devtools/blob/e31ec5825342eda570acfc9bcb43a44258fceb28/backend/getData.js\n   */\n  function createReactCompositeComponent(component) {\n  \tvar _currentElement = createReactElement(component);\n  \tvar node = component.base;\n\n  \tvar instance = {\n  \t\t// --- ReactDOMComponent properties\n  \t\tgetName: function getName() {\n  \t\t\treturn typeName(_currentElement);\n  \t\t},\n  \t\t_currentElement: createReactElement(component),\n  \t\tprops: component.props,\n  \t\tstate: component.state,\n  \t\tforceUpdate: component.forceUpdate.bind(component),\n  \t\tsetState: component.setState.bind(component),\n\n  \t\t// --- Additional properties used by preact devtools\n  \t\tnode: node\n  \t};\n\n  \t// React DevTools exposes the `_instance` field of the selected item in the\n  \t// component tree as `$r` in the console.  `_instance` must refer to a\n  \t// React Component (or compatible) class instance with `props` and `state`\n  \t// fields and `setState()`, `forceUpdate()` methods.\n  \tinstance._instance = component;\n\n  \t// If the root node returned by this component instance's render function\n  \t// was itself a composite component, there will be a `_component` property\n  \t// containing the child component instance.\n  \tif (component._component) {\n  \t\tinstance._renderedComponent = updateReactComponent(component._component);\n  \t} else {\n  \t\t// Otherwise, if the render() function returned an HTML/SVG element,\n  \t\t// create a ReactDOMComponent-like object for the DOM node itself.\n  \t\tinstance._renderedComponent = updateReactComponent(node);\n  \t}\n\n  \treturn instance;\n  }\n\n  /**\n   * Map of Component|Node to ReactDOMComponent|ReactCompositeComponent-like\n   * object.\n   *\n   * The same React*Component instance must be used when notifying devtools\n   * about the initial mount of a component and subsequent updates.\n   */\n  var instanceMap = new Map();\n\n  /**\n   * Update (and create if necessary) the ReactDOMComponent|ReactCompositeComponent-like\n   * instance for a given preact component instance or DOM Node.\n   *\n   * @param {Component|Node} componentOrNode\n   */\n  function updateReactComponent(componentOrNode) {\n  \tvar newInstance = componentOrNode instanceof Node ? createReactDOMComponent(componentOrNode) : createReactCompositeComponent(componentOrNode);\n  \tif (instanceMap.has(componentOrNode)) {\n  \t\tvar inst = instanceMap.get(componentOrNode);\n  \t\tObject.assign(inst, newInstance);\n  \t\treturn inst;\n  \t}\n  \tinstanceMap.set(componentOrNode, newInstance);\n  \treturn newInstance;\n  }\n\n  function nextRootKey(roots) {\n  \treturn '.' + Object.keys(roots).length;\n  }\n\n  /**\n   * Find all root component instances rendered by preact in `node`'s children\n   * and add them to the `roots` map.\n   *\n   * @param {DOMElement} node\n   * @param {[key: string] => ReactDOMComponent|ReactCompositeComponent}\n   */\n  function findRoots(node, roots) {\n  \tArray.from(node.childNodes).forEach(function (child) {\n  \t\tif (child._component) {\n  \t\t\troots[nextRootKey(roots)] = updateReactComponent(child._component);\n  \t\t} else {\n  \t\t\tfindRoots(child, roots);\n  \t\t}\n  \t});\n  }\n\n  /**\n   * Map of functional component name -> wrapper class.\n   */\n  var functionalComponentWrappers = new Map();\n\n  /**\n   * Wrap a functional component with a stateful component.\n   *\n   * preact does not record any information about the original hierarchy of\n   * functional components in the rendered DOM nodes. Wrapping functional components\n   * with a trivial wrapper allows us to recover information about the original\n   * component structure from the DOM.\n   *\n   * @param {VNode} vnode\n   */\n  function wrapFunctionalComponent(vnode) {\n  \tvar originalRender = vnode.nodeName;\n  \tvar name = vnode.nodeName.name || '(Function.name missing)';\n  \tvar wrappers = functionalComponentWrappers;\n  \tif (!wrappers.has(originalRender)) {\n  \t\t(function () {\n  \t\t\tvar wrapper = (function (_Component) {\n  \t\t\t\tbabelHelpers.inherits(wrapper, _Component);\n\n  \t\t\t\tfunction wrapper() {\n  \t\t\t\t\tbabelHelpers.classCallCheck(this, wrapper);\n\n  \t\t\t\t\t_Component.apply(this, arguments);\n  \t\t\t\t}\n\n  \t\t\t\twrapper.prototype.render = function render(props, state, context) {\n  \t\t\t\t\treturn originalRender(props, context);\n  \t\t\t\t};\n\n  \t\t\t\treturn wrapper;\n  \t\t\t})(preact.Component);\n\n  \t\t\t// Expose the original component name. React Dev Tools will use\n  \t\t\t// this property if it exists or fall back to Function.name\n  \t\t\t// otherwise.\n  \t\t\twrapper.displayName = name;\n\n  \t\t\twrappers.set(originalRender, wrapper);\n  \t\t})();\n  \t}\n  \tvnode.nodeName = wrappers.get(originalRender);\n  }\n\n  /**\n   * Create a bridge for exposing preact's component tree to React DevTools.\n   *\n   * It creates implementations of the interfaces that ReactDOM passes to\n   * devtools to enable it to query the component tree and hook into component\n   * updates.\n   *\n   * See https://github.com/facebook/react/blob/59ff7749eda0cd858d5ee568315bcba1be75a1ca/src/renderers/dom/ReactDOM.js\n   * for how ReactDOM exports its internals for use by the devtools and\n   * the `attachRenderer()` function in\n   * https://github.com/facebook/react-devtools/blob/e31ec5825342eda570acfc9bcb43a44258fceb28/backend/attachRenderer.js\n   * for how the devtools consumes the resulting objects.\n   */\n  function createDevToolsBridge() {\n  \t// The devtools has different paths for interacting with the renderers from\n  \t// React Native, legacy React DOM and current React DOM.\n  \t//\n  \t// Here we emulate the interface for the current React DOM (v15+) lib.\n\n  \t// ReactDOMComponentTree-like object\n  \tvar ComponentTree = {\n  \t\tgetNodeFromInstance: function getNodeFromInstance(instance) {\n  \t\t\treturn instance.node;\n  \t\t},\n  \t\tgetClosestInstanceFromNode: function getClosestInstanceFromNode(node) {\n  \t\t\twhile (node && !node._component) {\n  \t\t\t\tnode = node.parentNode;\n  \t\t\t}\n  \t\t\treturn node ? updateReactComponent(node._component) : null;\n  \t\t}\n  \t};\n\n  \t// Map of root ID (the ID is unimportant) to component instance.\n  \tvar roots = {};\n  \tfindRoots(document.body, roots);\n\n  \t// ReactMount-like object\n  \t//\n  \t// Used by devtools to discover the list of root component instances and get\n  \t// notified when new root components are rendered.\n  \tvar Mount = {\n  \t\t_instancesByReactRootID: roots,\n\n  \t\t// Stub - React DevTools expects to find this method and replace it\n  \t\t// with a wrapper in order to observe new root components being added\n  \t\t_renderNewRootComponent: function _renderNewRootComponent() /* instance, ... */{}\n  \t};\n\n  \t// ReactReconciler-like object\n  \tvar Reconciler = {\n  \t\t// Stubs - React DevTools expects to find these methods and replace them\n  \t\t// with wrappers in order to observe components being mounted, updated and\n  \t\t// unmounted\n  \t\tmountComponent: function mountComponent() /* instance, ... */{},\n  \t\tperformUpdateIfNecessary: function performUpdateIfNecessary() /* instance, ... */{},\n  \t\treceiveComponent: function receiveComponent() /* instance, ... */{},\n  \t\tunmountComponent: function unmountComponent() /* instance, ... */{}\n  \t};\n\n  \t/** Notify devtools that a new component instance has been mounted into the DOM. */\n  \tvar componentAdded = function componentAdded(component) {\n  \t\tvar instance = updateReactComponent(component);\n  \t\tif (isRootComponent(component)) {\n  \t\t\tinstance._rootID = nextRootKey(roots);\n  \t\t\troots[instance._rootID] = instance;\n  \t\t\tMount._renderNewRootComponent(instance);\n  \t\t}\n  \t\tvisitNonCompositeChildren(instance, function (childInst) {\n  \t\t\tchildInst._inDevTools = true;\n  \t\t\tReconciler.mountComponent(childInst);\n  \t\t});\n  \t\tReconciler.mountComponent(instance);\n  \t};\n\n  \t/** Notify devtools that a component has been updated with new props/state. */\n  \tvar componentUpdated = function componentUpdated(component) {\n  \t\tvar prevRenderedChildren = [];\n  \t\tvisitNonCompositeChildren(instanceMap.get(component), function (childInst) {\n  \t\t\tprevRenderedChildren.push(childInst);\n  \t\t});\n\n  \t\t// Notify devtools about updates to this component and any non-composite\n  \t\t// children\n  \t\tvar instance = updateReactComponent(component);\n  \t\tReconciler.receiveComponent(instance);\n  \t\tvisitNonCompositeChildren(instance, function (childInst) {\n  \t\t\tif (!childInst._inDevTools) {\n  \t\t\t\t// New DOM child component\n  \t\t\t\tchildInst._inDevTools = true;\n  \t\t\t\tReconciler.mountComponent(childInst);\n  \t\t\t} else {\n  \t\t\t\t// Updated DOM child component\n  \t\t\t\tReconciler.receiveComponent(childInst);\n  \t\t\t}\n  \t\t});\n\n  \t\t// For any non-composite children that were removed by the latest render,\n  \t\t// remove the corresponding ReactDOMComponent-like instances and notify\n  \t\t// the devtools\n  \t\tprevRenderedChildren.forEach(function (childInst) {\n  \t\t\tif (!document.body.contains(childInst.node)) {\n  \t\t\t\tinstanceMap['delete'](childInst.node);\n  \t\t\t\tReconciler.unmountComponent(childInst);\n  \t\t\t}\n  \t\t});\n  \t};\n\n  \t/** Notify devtools that a component has been unmounted from the DOM. */\n  \tvar componentRemoved = function componentRemoved(component) {\n  \t\tvar instance = updateReactComponent(component);\n  \t\tvisitNonCompositeChildren(function (childInst) {\n  \t\t\tinstanceMap['delete'](childInst.node);\n  \t\t\tReconciler.unmountComponent(childInst);\n  \t\t});\n  \t\tReconciler.unmountComponent(instance);\n  \t\tinstanceMap['delete'](component);\n  \t\tif (instance._rootID) {\n  \t\t\tdelete roots[instance._rootID];\n  \t\t}\n  \t};\n\n  \treturn {\n  \t\tcomponentAdded: componentAdded,\n  \t\tcomponentUpdated: componentUpdated,\n  \t\tcomponentRemoved: componentRemoved,\n\n  \t\t// Interfaces passed to devtools via __REACT_DEVTOOLS_GLOBAL_HOOK__.inject()\n  \t\tComponentTree: ComponentTree,\n  \t\tMount: Mount,\n  \t\tReconciler: Reconciler\n  \t};\n  }\n\n  /**\n   * Return `true` if a preact component is a top level component rendered by\n   * `render()` into a container Element.\n   */\n  function isRootComponent(component) {\n  \treturn !component.base.parentElement || !component.base.parentElement[ATTR_KEY];\n  }\n\n  /**\n   * Visit all child instances of a ReactCompositeComponent-like object that are\n   * not composite components (ie. they represent DOM elements or text)\n   *\n   * @param {Component} component\n   * @param {(Component) => void} visitor\n   */\n  function visitNonCompositeChildren(component, visitor) {\n  \tif (component._renderedComponent) {\n  \t\tif (!component._renderedComponent._component) {\n  \t\t\tvisitor(component._renderedComponent);\n  \t\t\tvisitNonCompositeChildren(component._renderedComponent, visitor);\n  \t\t}\n  \t} else if (component._renderedChildren) {\n  \t\tcomponent._renderedChildren.forEach(function (child) {\n  \t\t\tvisitor(child);\n  \t\t\tif (!child._component) visitNonCompositeChildren(child, visitor);\n  \t\t});\n  \t}\n  }\n\n  /**\n   * Create a bridge between the preact component tree and React's dev tools\n   * and register it.\n   *\n   * After this function is called, the React Dev Tools should be able to detect\n   * \"React\" on the page and show the component tree.\n   *\n   * This function hooks into preact VNode creation in order to expose functional\n   * components correctly, so it should be called before the root component(s)\n   * are rendered.\n   *\n   * Returns a cleanup function which unregisters the hooks.\n   */\n\n  function initDevTools() {\n  \tif (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n  \t\t// React DevTools are not installed\n  \t\treturn;\n  \t}\n\n  \t// Hook into preact element creation in order to wrap functional components\n  \t// with stateful ones in order to make them visible in the devtools\n  \tvar nextVNode = preact.options.vnode;\n  \tpreact.options.vnode = function (vnode) {\n  \t\tif (isFunctionalComponent(vnode)) wrapFunctionalComponent(vnode);\n  \t\tif (nextVNode) return nextVNode(vnode);\n  \t};\n\n  \t// Notify devtools when preact components are mounted, updated or unmounted\n  \tvar bridge = createDevToolsBridge();\n\n  \tvar nextAfterMount = preact.options.afterMount;\n  \tpreact.options.afterMount = function (component) {\n  \t\tbridge.componentAdded(component);\n  \t\tif (nextAfterMount) nextAfterMount(component);\n  \t};\n\n  \tvar nextAfterUpdate = preact.options.afterUpdate;\n  \tpreact.options.afterUpdate = function (component) {\n  \t\tbridge.componentUpdated(component);\n  \t\tif (nextAfterUpdate) nextAfterUpdate(component);\n  \t};\n\n  \tvar nextBeforeUnmount = preact.options.beforeUnmount;\n  \tpreact.options.beforeUnmount = function (component) {\n  \t\tbridge.componentRemoved(component);\n  \t\tif (nextBeforeUnmount) nextBeforeUnmount(component);\n  \t};\n\n  \t// Notify devtools about this instance of \"React\"\n  \t__REACT_DEVTOOLS_GLOBAL_HOOK__.inject(bridge);\n\n  \treturn function () {\n  \t\tpreact.options.afterMount = nextAfterMount;\n  \t\tpreact.options.afterUpdate = nextAfterUpdate;\n  \t\tpreact.options.beforeUnmount = nextBeforeUnmount;\n  \t};\n  }\n\n  initDevTools();\n\n}));\n//# sourceMappingURL=devtools.js.map\n"
    },
    {
      "id": 4,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/conversions.js",
      "name": "./~/color-convert/conversions.js",
      "index": 17,
      "index2": 12,
      "size": 16573,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color-convert/index.js",
      "issuerId": 17,
      "issuerName": "./~/color-convert/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 17,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/index.js",
          "module": "./~/color-convert/index.js",
          "moduleName": "./~/color-convert/index.js",
          "type": "cjs require",
          "userRequest": "./conversions",
          "loc": "1:18-42"
        },
        {
          "moduleId": 18,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/route.js",
          "module": "./~/color-convert/route.js",
          "moduleName": "./~/color-convert/route.js",
          "type": "cjs require",
          "userRequest": "./conversions",
          "loc": "1:18-42"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/* MIT license */\nvar cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n\tif (cssKeywords.hasOwnProperty(key)) {\n\t\treverseKeywords[cssKeywords[key]] = key;\n\t}\n}\n\nvar convert = module.exports = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\n// hide .channels and .labels properties\nfor (var model in convert) {\n\tif (convert.hasOwnProperty(model)) {\n\t\tif (!('channels' in convert[model])) {\n\t\t\tthrow new Error('missing channels property: ' + model);\n\t\t}\n\n\t\tif (!('labels' in convert[model])) {\n\t\t\tthrow new Error('missing channel labels property: ' + model);\n\t\t}\n\n\t\tif (convert[model].labels.length !== convert[model].channels) {\n\t\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t\t}\n\n\t\tvar channels = convert[model].channels;\n\t\tvar labels = convert[model].labels;\n\t\tdelete convert[model].channels;\n\t\tdelete convert[model].labels;\n\t\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\t\tObject.defineProperty(convert[model], 'labels', {value: labels});\n\t}\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar l;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tl = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tvar h;\n\tvar s;\n\tvar v;\n\n\tif (max === 0) {\n\t\ts = 0;\n\t} else {\n\t\ts = (delta / max * 1000) / 10;\n\t}\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tv = ((max / 255) * 1000) / 10;\n\n\treturn [h, s, v];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tvar r = rgb[0];\n\tvar g = rgb[1];\n\tvar b = rgb[2];\n\tvar h = convert.rgb.hsl(rgb)[0];\n\tvar w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar c;\n\tvar m;\n\tvar y;\n\tvar k;\n\n\tk = Math.min(1 - r, 1 - g, 1 - b);\n\tc = (1 - r - k) / (1 - k) || 0;\n\tm = (1 - g - k) / (1 - k) || 0;\n\ty = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\n/**\n * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n * */\nfunction comparativeDistance(x, y) {\n\treturn (\n\t\tMath.pow(x[0] - y[0], 2) +\n\t\tMath.pow(x[1] - y[1], 2) +\n\t\tMath.pow(x[2] - y[2], 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tvar reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tvar currentClosestDistance = Infinity;\n\tvar currentClosestKeyword;\n\n\tfor (var keyword in cssKeywords) {\n\t\tif (cssKeywords.hasOwnProperty(keyword)) {\n\t\t\tvar value = cssKeywords[keyword];\n\n\t\t\t// Compute comparative distance\n\t\t\tvar distance = comparativeDistance(rgb, value);\n\n\t\t\t// Check if its less, if so set as closest\n\t\t\tif (distance < currentClosestDistance) {\n\t\t\t\tcurrentClosestDistance = distance;\n\t\t\t\tcurrentClosestKeyword = keyword;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\n\t// assume sRGB\n\tr = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tvar x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tvar y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tvar z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tvar xyz = convert.rgb.xyz(rgb);\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tvar h = hsl[0] / 360;\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar t1;\n\tvar t2;\n\tvar t3;\n\tvar rgb;\n\tvar val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tt1 = 2 * l - t2;\n\n\trgb = [0, 0, 0];\n\tfor (var i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tvar h = hsl[0];\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar smin = s;\n\tvar lmin = Math.max(l, 0.01);\n\tvar sv;\n\tvar v;\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tv = (l + s) / 2;\n\tsv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tvar h = hsv[0] / 60;\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar hi = Math.floor(h) % 6;\n\n\tvar f = h - Math.floor(h);\n\tvar p = 255 * v * (1 - s);\n\tvar q = 255 * v * (1 - (s * f));\n\tvar t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tvar h = hsv[0];\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\tvar vmin = Math.max(v, 0.01);\n\tvar lmin;\n\tvar sl;\n\tvar l;\n\n\tl = (2 - s) * v;\n\tlmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tvar h = hwb[0] / 360;\n\tvar wh = hwb[1] / 100;\n\tvar bl = hwb[2] / 100;\n\tvar ratio = wh + bl;\n\tvar i;\n\tvar v;\n\tvar f;\n\tvar n;\n\n\t// wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\ti = Math.floor(6 * h);\n\tv = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tn = wh + f * (v - wh); // linear interpolation\n\n\tvar r;\n\tvar g;\n\tvar b;\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v; g = n; b = wh; break;\n\t\tcase 1: r = n; g = v; b = wh; break;\n\t\tcase 2: r = wh; g = v; b = n; break;\n\t\tcase 3: r = wh; g = n; b = v; break;\n\t\tcase 4: r = n; g = wh; b = v; break;\n\t\tcase 5: r = v; g = wh; b = n; break;\n\t}\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tvar c = cmyk[0] / 100;\n\tvar m = cmyk[1] / 100;\n\tvar y = cmyk[2] / 100;\n\tvar k = cmyk[3] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = 1 - Math.min(1, c * (1 - k) + k);\n\tg = 1 - Math.min(1, m * (1 - k) + k);\n\tb = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tvar x = xyz[0] / 100;\n\tvar y = xyz[1] / 100;\n\tvar z = xyz[2] / 100;\n\tvar r;\n\tvar g;\n\tvar b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tvar x = xyz[0];\n\tvar y = xyz[1];\n\tvar z = xyz[2];\n\tvar l;\n\tvar a;\n\tvar b;\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);\n\n\tl = (116 * y) - 16;\n\ta = 500 * (x - y);\n\tb = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar x;\n\tvar y;\n\tvar z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tvar y2 = Math.pow(y, 3);\n\tvar x2 = Math.pow(x, 3);\n\tvar z2 = Math.pow(z, 3);\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tvar l = lab[0];\n\tvar a = lab[1];\n\tvar b = lab[2];\n\tvar hr;\n\tvar h;\n\tvar c;\n\n\thr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tc = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tvar l = lch[0];\n\tvar c = lch[1];\n\tvar h = lch[2];\n\tvar a;\n\tvar b;\n\tvar hr;\n\n\thr = h / 360 * 2 * Math.PI;\n\ta = c * Math.cos(hr);\n\tb = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\tvar value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tvar ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tvar r = args[0];\n\tvar g = args[1];\n\tvar b = args[2];\n\n\t// we use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tvar ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tvar color = args % 10;\n\n\t// handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tvar mult = (~~(args > 50) + 1) * 0.5;\n\tvar r = ((color & 1) * mult) * 255;\n\tvar g = (((color >> 1) & 1) * mult) * 255;\n\tvar b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// handle greyscale\n\tif (args >= 232) {\n\t\tvar c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tvar rem;\n\tvar r = Math.floor(args / 36) / 5 * 255;\n\tvar g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tvar b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tvar integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tvar match = args.toString(16).match(/[a-f0-9]{6}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tvar integer = parseInt(match[0], 16);\n\tvar r = (integer >> 16) & 0xFF;\n\tvar g = (integer >> 8) & 0xFF;\n\tvar b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tvar r = rgb[0] / 255;\n\tvar g = rgb[1] / 255;\n\tvar b = rgb[2] / 255;\n\tvar max = Math.max(Math.max(r, g), b);\n\tvar min = Math.min(Math.min(r, g), b);\n\tvar chroma = (max - min);\n\tvar grayscale;\n\tvar hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma + 4;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tvar s = hsl[1] / 100;\n\tvar l = hsl[2] / 100;\n\tvar c = 1;\n\tvar f = 0;\n\n\tif (l < 0.5) {\n\t\tc = 2.0 * s * l;\n\t} else {\n\t\tc = 2.0 * s * (1.0 - l);\n\t}\n\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tvar s = hsv[1] / 100;\n\tvar v = hsv[2] / 100;\n\n\tvar c = s * v;\n\tvar f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tvar h = hcg[0] / 360;\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tvar pure = [0, 0, 0];\n\tvar hi = (h % 1) * 6;\n\tvar v = hi % 1;\n\tvar w = 1 - v;\n\tvar mg = 0;\n\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar v = c + g * (1.0 - c);\n\tvar f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\n\tvar l = g * (1.0 - c) + 0.5 * c;\n\tvar s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tvar c = hcg[1] / 100;\n\tvar g = hcg[2] / 100;\n\tvar v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tvar w = hwb[1] / 100;\n\tvar b = hwb[2] / 100;\n\tvar v = 1 - b;\n\tvar c = v - w;\n\tvar g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = convert.gray.hsv = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tvar val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tvar integer = (val << 16) + (val << 8) + val;\n\n\tvar string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tvar val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n"
    },
    {
      "id": 5,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color-name/index.js",
      "name": "./~/color-name/index.js",
      "index": 13,
      "index2": 8,
      "size": 4599,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color-string/index.js",
      "issuerId": 19,
      "issuerName": "./~/color-string/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 4,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/conversions.js",
          "module": "./~/color-convert/conversions.js",
          "moduleName": "./~/color-convert/conversions.js",
          "type": "cjs require",
          "userRequest": "color-name",
          "loc": "2:18-39"
        },
        {
          "moduleId": 19,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-string/index.js",
          "module": "./~/color-string/index.js",
          "moduleName": "./~/color-string/index.js",
          "type": "cjs require",
          "userRequest": "color-name",
          "loc": "2:17-38"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "module.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};"
    },
    {
      "id": 6,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/get-size/get-size.js",
      "name": "./~/get-size/get-size.js",
      "index": 23,
      "index2": 18,
      "size": 5296,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "get-size/get-size",
          "loc": "7:4-16:6"
        },
        {
          "moduleId": 24,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/cell.js",
          "module": "./~/flickity/js/cell.js",
          "moduleName": "./~/flickity/js/cell.js",
          "type": "amd require",
          "userRequest": "get-size/get-size",
          "loc": "7:4-11:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/*!\n * getSize v2.0.2\n * measure size of elements\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n/*global define: false, module: false, console: false */\n\n( function( window, factory ) {\n  'use strict';\n\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( function() {\n      return factory();\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.getSize = factory();\n  }\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See http://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * WebKit measures the outer-width on style.width on border-box elems\n   * IE & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n\n  getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;\n  body.removeChild( div );\n\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n"
    },
    {
      "id": 7,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/tap-listener/tap-listener.js",
      "name": "./~/tap-listener/tap-listener.js",
      "index": 33,
      "index2": 28,
      "size": 2636,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/page-dots.js",
      "issuerId": 28,
      "issuerName": "./~/flickity/js/page-dots.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 28,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/page-dots.js",
          "module": "./~/flickity/js/page-dots.js",
          "moduleName": "./~/flickity/js/page-dots.js",
          "type": "amd require",
          "userRequest": "tap-listener/tap-listener",
          "loc": "7:4-13:6"
        },
        {
          "moduleId": 30,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/prev-next-button.js",
          "module": "./~/flickity/js/prev-next-button.js",
          "moduleName": "./~/flickity/js/prev-next-button.js",
          "type": "amd require",
          "userRequest": "tap-listener/tap-listener",
          "loc": "7:4-13:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/*!\n * Tap listener v2.0.0\n * listens to taps\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false*/ /*globals define, module, require */\n\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'unipointer/unipointer'\n    ], function( Unipointer ) {\n      return factory( window, Unipointer );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('unipointer')\n    );\n  } else {\n    // browser global\n    window.TapListener = factory(\n      window,\n      window.Unipointer\n    );\n  }\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// --------------------------  TapListener -------------------------- //\n\nfunction TapListener( elem ) {\n  this.bindTap( elem );\n}\n\n// inherit Unipointer & EventEmitter\nvar proto = TapListener.prototype = Object.create( Unipointer.prototype );\n\n/**\n * bind tap event to element\n * @param {Element} elem\n */\nproto.bindTap = function( elem ) {\n  if ( !elem ) {\n    return;\n  }\n  this.unbindTap();\n  this.tapElement = elem;\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindTap = function() {\n  if ( !this.tapElement ) {\n    return;\n  }\n  this._bindStartEvent( this.tapElement, true );\n  delete this.tapElement;\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  var pointerPoint = Unipointer.getPointerPoint( pointer );\n  var boundingRect = this.tapElement.getBoundingClientRect();\n  var scrollX = window.pageXOffset;\n  var scrollY = window.pageYOffset;\n  // calculate if pointer is inside tapElement\n  var isInside = pointerPoint.x >= boundingRect.left + scrollX &&\n    pointerPoint.x <= boundingRect.right + scrollX &&\n    pointerPoint.y >= boundingRect.top + scrollY &&\n    pointerPoint.y <= boundingRect.bottom + scrollY;\n  // trigger callback if pointer is inside element\n  if ( isInside ) {\n    this.emitEvent( 'tap', [ event, pointer ] );\n  }\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    var _this = this;\n    setTimeout( function() {\n      delete _this.isIgnoringMouseUp;\n    }, 400 );\n  }\n};\n\nproto.destroy = function() {\n  this.pointerDone();\n  this.unbindTap();\n};\n\n// -----  ----- //\n\nreturn TapListener;\n\n}));\n"
    },
    {
      "id": 8,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/unipointer/unipointer.js",
      "name": "./~/unipointer/unipointer.js",
      "index": 31,
      "index2": 25,
      "size": 7201,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/unidragger/unidragger.js",
      "issuerId": 37,
      "issuerName": "./~/unidragger/unidragger.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 7,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/tap-listener/tap-listener.js",
          "module": "./~/tap-listener/tap-listener.js",
          "moduleName": "./~/tap-listener/tap-listener.js",
          "type": "amd require",
          "userRequest": "unipointer/unipointer",
          "loc": "15:4-19:6"
        },
        {
          "moduleId": 37,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/unidragger/unidragger.js",
          "module": "./~/unidragger/unidragger.js",
          "moduleName": "./~/unidragger/unidragger.js",
          "type": "amd require",
          "userRequest": "unipointer/unipointer",
          "loc": "15:4-19:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 6,
      "source": "/*!\n * Unipointer v2.1.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'ev-emitter/ev-emitter'\n    ], function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('ev-emitter')\n    );\n  } else {\n    // browser global\n    window.Unipointer = factory(\n      window,\n      window.EvEmitter\n    );\n  }\n\n}( window, function factory( window, EvEmitter ) {\n\n'use strict';\n\nfunction noop() {}\n\nfunction Unipointer() {}\n\n// inherit EvEmitter\nvar proto = Unipointer.prototype = Object.create( EvEmitter.prototype );\n\nproto.bindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, false );\n};\n\n/**\n * works as unbinder, as you can ._bindStart( false ) to unbind\n * @param {Boolean} isBind - will unbind if falsey\n */\nproto._bindStartEvent = function( elem, isBind ) {\n  // munge isBind, default to true\n  isBind = isBind === undefined ? true : !!isBind;\n  var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';\n\n  if ( window.navigator.pointerEnabled ) {\n    // W3C Pointer Events, IE11. See https://coderwall.com/p/mfreca\n    elem[ bindMethod ]( 'pointerdown', this );\n  } else if ( window.navigator.msPointerEnabled ) {\n    // IE10 Pointer Events\n    elem[ bindMethod ]( 'MSPointerDown', this );\n  } else {\n    // listen for both, for devices like Chrome Pixel\n    elem[ bindMethod ]( 'mousedown', this );\n    elem[ bindMethod ]( 'touchstart', this );\n  }\n};\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// returns the touch that we're keeping track of\nproto.getTouch = function( touches ) {\n  for ( var i=0; i < touches.length; i++ ) {\n    var touch = touches[i];\n    if ( touch.identifier == this.pointerIdentifier ) {\n      return touch;\n    }\n  }\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  // dismiss clicks from right or middle buttons\n  var button = event.button;\n  if ( button && ( button !== 0 && button !== 1 ) ) {\n    return;\n  }\n  this._pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this._pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onMSPointerDown =\nproto.onpointerdown = function( event ) {\n  this._pointerDown( event, event );\n};\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto._pointerDown = function( event, pointer ) {\n  // dismiss other pointers\n  if ( this.isPointerDown ) {\n    return;\n  }\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n  this.pointerDown( event, pointer );\n};\n\nproto.pointerDown = function( event, pointer ) {\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// hash of events to be bound after start event\nvar postStartEvents = {\n  mousedown: [ 'mousemove', 'mouseup' ],\n  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],\n  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],\n  MSPointerDown: [ 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel' ]\n};\n\nproto._bindPostStartEvents = function( event ) {\n  if ( !event ) {\n    return;\n  }\n  // get proper events to match start event\n  var events = postStartEvents[ event.type ];\n  // bind events to node\n  events.forEach( function( eventName ) {\n    window.addEventListener( eventName, this );\n  }, this );\n  // save these arguments\n  this._boundPointerEvents = events;\n};\n\nproto._unbindPostStartEvents = function() {\n  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n  if ( !this._boundPointerEvents ) {\n    return;\n  }\n  this._boundPointerEvents.forEach( function( eventName ) {\n    window.removeEventListener( eventName, this );\n  }, this );\n\n  delete this._boundPointerEvents;\n};\n\n// ----- move event ----- //\n\nproto.onmousemove = function( event ) {\n  this._pointerMove( event, event );\n};\n\nproto.onMSPointerMove =\nproto.onpointermove = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerMove( event, event );\n  }\n};\n\nproto.ontouchmove = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerMove( event, touch );\n  }\n};\n\n/**\n * pointer move\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerMove = function( event, pointer ) {\n  this.pointerMove( event, pointer );\n};\n\n// public\nproto.pointerMove = function( event, pointer ) {\n  this.emitEvent( 'pointerMove', [ event, pointer ] );\n};\n\n// ----- end event ----- //\n\n\nproto.onmouseup = function( event ) {\n  this._pointerUp( event, event );\n};\n\nproto.onMSPointerUp =\nproto.onpointerup = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerUp( event, event );\n  }\n};\n\nproto.ontouchend = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerUp( event, touch );\n  }\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerUp = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerUp( event, pointer );\n};\n\n// public\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n};\n\n// ----- pointer done ----- //\n\n// triggered on pointer up & pointer cancel\nproto._pointerDone = function() {\n  // reset properties\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n  // remove events\n  this._unbindPostStartEvents();\n  this.pointerDone();\n};\n\nproto.pointerDone = noop;\n\n// ----- pointer cancel ----- //\n\nproto.onMSPointerCancel =\nproto.onpointercancel = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerCancel( event, event );\n  }\n};\n\nproto.ontouchcancel = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerCancel( event, touch );\n  }\n};\n\n/**\n * pointer cancel\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerCancel = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerCancel( event, pointer );\n};\n\n// public\nproto.pointerCancel = function( event, pointer ) {\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// -----  ----- //\n\n// utility function for getting x/y coords from event\nUnipointer.getPointerPoint = function( pointer ) {\n  return {\n    x: pointer.pageX,\n    y: pointer.pageY\n  };\n};\n\n// -----  ----- //\n\nreturn Unipointer;\n\n}));\n"
    },
    {
      "id": 9,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "name": "./_js/main.js",
      "index": 3,
      "index2": 37,
      "size": 181,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "multi preact/devtools ./_js/main.js",
      "issuerId": 38,
      "issuerName": "multi preact/devtools ./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 38,
          "moduleIdentifier": "multi preact/devtools ./_js/main.js",
          "module": "multi preact/devtools ./_js/main.js",
          "moduleName": "multi preact/devtools ./_js/main.js",
          "type": "single entry",
          "userRequest": "./_js/main.js",
          "loc": "main:100001"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 1,
      "source": "'use strict';\n\nrequire('./menu.js');\n\nrequire('./find-us.js');\n\nrequire('./food.js');\n\nrequire('./footer.js');\n\nrequire('./header.js');\n\nrequire('./hero.js');\n\nrequire('./home.js');"
    },
    {
      "id": 10,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/find-us.js",
      "name": "./_js/find-us.js",
      "index": 5,
      "index2": 4,
      "size": 316,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./find-us.js",
          "loc": "5:0-23"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "'use strict';\n\nvar _preact = require('preact');\n\nvar _Ad = require('./components/Ad.js');\n\nvar _Ad2 = _interopRequireDefault(_Ad);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _preact.render)((0, _preact.h)(_Ad2.default, null), document.querySelector('#ad'));"
    },
    {
      "id": 11,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/food.js",
      "name": "./_js/food.js",
      "index": 7,
      "index2": 6,
      "size": 2257,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./food.js",
          "loc": "7:0-20"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "'use strict';\n\nvar _scrollreveal = require('scrollreveal');\n\nvar _scrollreveal2 = _interopRequireDefault(_scrollreveal);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar imageMenuItemListsSection = document.querySelector('#image-menu-item-lists');\nvar tabs = imageMenuItemListsSection.querySelector('.tabs');\nvar content = imageMenuItemListsSection.querySelector('.content');\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n\tfor (var _iterator = Array.from(tabs.querySelectorAll('.tab-link'))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\tvar tabLink = _step.value;\n\n\t\ttabLink.addEventListener('click', function (event) {\n\t\t\tevent.preventDefault();\n\n\t\t\tArray.from(content.querySelectorAll('.active')).map(function (activeGroup) {\n\t\t\t\tactiveGroup.classList.remove('active');\n\t\t\t});\n\t\t\tArray.from(tabs.querySelectorAll('.tab-link.active')).map(function (activeLink) {\n\t\t\t\tif (activeLink !== event.target) activeLink.classList.remove('active');\n\t\t\t});\n\n\t\t\tevent.target.classList.toggle('active');\n\t\t\tif (event.target.classList.contains('active')) {\n\t\t\t\tvar group = event.target.getAttribute('href');\n\t\t\t\tcontent.querySelector(group).classList.add('active');\n\t\t\t}\n\t\t});\n\t}\n} catch (err) {\n\t_didIteratorError = true;\n\t_iteratorError = err;\n} finally {\n\ttry {\n\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t_iterator.return();\n\t\t}\n\t} finally {\n\t\tif (_didIteratorError) {\n\t\t\tthrow _iteratorError;\n\t\t}\n\t}\n}\n\nvar showMenuButton = document.querySelector('#show-menu');\nvar menu = document.querySelector('#menu');\nshowMenuButton.addEventListener('click', function (event) {\n\tevent.preventDefault();\n\n\tmenu.classList.toggle('collapsed');\n\n\tif (menu.classList.contains('collapsed')) showMenuButton.textContent = 'Show full menu';else showMenuButton.textContent = 'Hide full menu';\n});\n\n(0, _scrollreveal2.default)().reveal('.food-special-details', {\n\tduration: 500,\n\topacity: 0,\n\tdistance: '500px',\n\teasing: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',\n\tviewFactor: 1.3,\n\tafterReveal: function afterReveal(special) {\n\t\tspecial.classList.add('revealed');\n\t}\n}, 50);"
    },
    {
      "id": 12,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/footer.js",
      "name": "./_js/footer.js",
      "index": 9,
      "index2": 7,
      "size": 1831,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./footer.js",
          "loc": "9:0-22"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "'use strict';\n\nvar picture = document.querySelector('#coyote-grill-external');\nvar pictureSwitch = document.querySelector('#coyote-grill-external-switch');\n\nvar dayWide = '/images/front-wide.jpg';\nvar day = '/images/front.jpg';\nvar nightWide = '/images/front-wide-night.jpg';\nvar night = '/images/front-night.jpg';\n\nvar now = new Date();\nif (now.getHours() < 6 || now.getHours() > 17) {\n\tpicture.classList.remove('day-picture');\n\tpicture.classList.add('night-picture');\n\tpicture.querySelector('source').setAttribute('srcset', nightWide);\n\tpicture.querySelector('img').setAttribute('src', night);\n\n\tpictureSwitch.querySelector('#external-night').checked = true;\n}\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n\tfor (var _iterator = Array.from(pictureSwitch.querySelectorAll('input[name=\"coyote-grill-external-switch\"]'))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\tvar option = _step.value;\n\n\t\toption.addEventListener('change', function (event) {\n\t\t\tif (event.target.checked) {\n\t\t\t\tpicture.style.opacity = 0;\n\n\t\t\t\tswitch (event.target.value) {\n\t\t\t\t\tcase 'night':\n\t\t\t\t\t\tpicture.querySelector('source').setAttribute('srcset', nightWide);\n\t\t\t\t\t\tpicture.querySelector('img').setAttribute('src', night);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'day':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpicture.querySelector('source').setAttribute('srcset', dayWide);\n\t\t\t\t\t\tpicture.querySelector('img').setAttribute('src', day);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tpicture.style.opacity = null;\n\t\t\t}\n\t\t});\n\t}\n} catch (err) {\n\t_didIteratorError = true;\n\t_iteratorError = err;\n} finally {\n\ttry {\n\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t_iterator.return();\n\t\t}\n\t} finally {\n\t\tif (_didIteratorError) {\n\t\t\tthrow _iteratorError;\n\t\t}\n\t}\n}"
    },
    {
      "id": 13,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/header.js",
      "name": "./_js/header.js",
      "index": 10,
      "index2": 16,
      "size": 2916,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./header.js",
          "loc": "11:0-22"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "'use strict';\n\nvar _color = require('color');\n\nvar _color2 = _interopRequireDefault(_color);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hero = document.querySelector('.carousel-overlay');\nvar header = document.querySelector('header.site-header');\nvar collapseMargin = 60;\nvar expandMargin = 200;\n\nvar initialHeroBackgroundColor = hero.style.backgroundColor;\nhero.style.backgroundColor = null;\nvar heroBackgroundColor = new _color2.default(window.getComputedStyle(hero).getPropertyValue('background-color'));\nif (initialHeroBackgroundColor) hero.style.backgroundColor = initialHeroBackgroundColor;\n\nvar isCollapsed = header.classList.contains('collapsed');\nif (!isCollapsed) header.classList.add('collapsed');\nvar headerBackgroundColor = new _color2.default(window.getComputedStyle(header).getPropertyValue('background-color'));\nif (!isCollapsed) header.classList.remove('collapsed');\n\nif (header.classList.contains('expanded') && hero.getBoundingClientRect().bottom < header.getBoundingClientRect().bottom + collapseMargin) {\n\theader.classList.add('notransition');\n\theader.classList.remove('expanded');\n\theader.classList.add('collapsed');\n\twindow.requestAnimationFrame(function () {\n\t\twindow.requestAnimationFrame(function () {\n\t\t\theader.classList.remove('notransition');\n\t\t});\n\t});\n}\n\n['resize', 'scroll'].map(function (event) {\n\twindow.addEventListener(event, function () {\n\t\twindow.requestAnimationFrame(step);\n\t});\n});\n\nfunction step() {\n\tvar heroRect = hero.getBoundingClientRect();\n\tvar headerHeight = header.clientHeight;\n\tvar headerRect = header.getBoundingClientRect();\n\n\tif (header.classList.contains('expanded')) {\n\t\tif (heroRect.bottom < headerRect.bottom + collapseMargin) {\n\n\t\t\theader.classList.remove('expanded');\n\t\t}\n\t} else {\n\t\tif (heroRect.bottom > headerRect.bottom + expandMargin) {\n\n\t\t\theader.classList.add('expanded');\n\t\t}\n\t}\n\n\tif (header.classList.contains('collapsed')) {\n\t\tif (heroRect.bottom > headerHeight) {\n\t\t\theader.classList.remove('collapsed');\n\t\t}\n\t} else {\n\t\tif (heroRect.bottom < headerHeight) {\n\t\t\theader.classList.add('collapsed');\n\t\t}\n\t}\n\n\tvar scrolledValue = (heroRect.height - (heroRect.bottom - headerHeight)) / heroRect.height;\n\tscrolledValue > 0 ? scrolledValue : 0;\n\tscrolledValue < 1 ? scrolledValue : 1;\n\n\tvar newHeroColor = (0, _color2.default)().red(heroBackgroundColor.red() + Math.pow(scrolledValue, 2) * (headerBackgroundColor.red() - heroBackgroundColor.red())).green(heroBackgroundColor.green() + Math.pow(scrolledValue, 2) * (headerBackgroundColor.green() - heroBackgroundColor.green())).blue(heroBackgroundColor.blue() + Math.pow(scrolledValue, 2) * (headerBackgroundColor.blue() - heroBackgroundColor.blue())).alpha(heroBackgroundColor.alpha() + Math.pow(scrolledValue, 2) * (headerBackgroundColor.alpha() - heroBackgroundColor.alpha())).rgb().string(0);\n\n\thero.style.backgroundColor = newHeroColor;\n}"
    },
    {
      "id": 14,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/hero.js",
      "name": "./_js/hero.js",
      "index": 19,
      "index2": 35,
      "size": 328,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./hero.js",
          "loc": "13:0-20"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "'use strict';\n\nvar _flickity = require('flickity');\n\nvar _flickity2 = _interopRequireDefault(_flickity);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar flickity = new _flickity2.default('.carousel', {\n\tcellSelector: '.carousel-image',\n\twrapAround: true,\n\tautoPlay: true\n});"
    },
    {
      "id": 15,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/home.js",
      "name": "./_js/home.js",
      "index": 38,
      "index2": 36,
      "size": 13,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./home.js",
          "loc": "15:0-20"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "\"use strict\";"
    },
    {
      "id": 16,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/menu.js",
      "name": "./_js/menu.js",
      "index": 4,
      "index2": 2,
      "size": 13,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
      "issuerId": 9,
      "issuerName": "./_js/main.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 9,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/main.js",
          "module": "./_js/main.js",
          "moduleName": "./_js/main.js",
          "type": "cjs require",
          "userRequest": "./menu.js",
          "loc": "3:0-20"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "\"use strict\";"
    },
    {
      "id": 17,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/index.js",
      "name": "./~/color-convert/index.js",
      "index": 16,
      "index2": 14,
      "size": 1725,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color/index.js",
      "issuerId": 20,
      "issuerName": "./~/color/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 20,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color/index.js",
          "module": "./~/color/index.js",
          "moduleName": "./~/color/index.js",
          "type": "cjs require",
          "userRequest": "color-convert",
          "loc": "4:14-38"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "var conversions = require('./conversions');\nvar route = require('./route');\n\nvar convert = {};\n\nvar models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tvar wrappedFn = function (args) {\n\t\tif (args === undefined || args === null) {\n\t\t\treturn args;\n\t\t}\n\n\t\tif (arguments.length > 1) {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t}\n\n\t\tvar result = fn(args);\n\n\t\t// we're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (var len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(function (fromModel) {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tvar routes = route(fromModel);\n\tvar routeModels = Object.keys(routes);\n\n\trouteModels.forEach(function (toModel) {\n\t\tvar fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n"
    },
    {
      "id": 18,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/route.js",
      "name": "./~/color-convert/route.js",
      "index": 18,
      "index2": 13,
      "size": 2226,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color-convert/index.js",
      "issuerId": 17,
      "issuerName": "./~/color-convert/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 17,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-convert/index.js",
          "module": "./~/color-convert/index.js",
          "moduleName": "./~/color-convert/index.js",
          "type": "cjs require",
          "userRequest": "./route",
          "loc": "2:12-30"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\n// https://jsperf.com/object-keys-vs-for-in-with-closure/3\nvar models = Object.keys(conversions);\n\nfunction buildGraph() {\n\tvar graph = {};\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n"
    },
    {
      "id": 19,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color-string/index.js",
      "name": "./~/color-string/index.js",
      "index": 12,
      "index2": 11,
      "size": 4925,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color/index.js",
      "issuerId": 20,
      "issuerName": "./~/color/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 20,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color/index.js",
          "module": "./~/color/index.js",
          "moduleName": "./~/color/index.js",
          "type": "cjs require",
          "userRequest": "color-string",
          "loc": "3:18-41"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "/* MIT license */\nvar colorNames = require('color-name');\nvar swizzle = require('simple-swizzle');\n\nvar reverseNames = {};\n\n// create a list of reverse color names\nfor (var name in colorNames) {\n\tif (colorNames.hasOwnProperty(name)) {\n\t\treverseNames[colorNames[name]] = name;\n\t}\n}\n\nvar cs = module.exports = {\n\tto: {}\n};\n\ncs.get = function (string) {\n\tvar prefix = string.substring(0, 3).toLowerCase();\n\tvar val;\n\tvar model;\n\tswitch (prefix) {\n\t\tcase 'hsl':\n\t\t\tval = cs.get.hsl(string);\n\t\t\tmodel = 'hsl';\n\t\t\tbreak;\n\t\tcase 'hwb':\n\t\t\tval = cs.get.hwb(string);\n\t\t\tmodel = 'hwb';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tval = cs.get.rgb(string);\n\t\t\tmodel = 'rgb';\n\t\t\tbreak;\n\t}\n\n\tif (!val) {\n\t\treturn null;\n\t}\n\n\treturn {model: model, value: val};\n};\n\ncs.get.rgb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar abbr = /^#([a-fA-F0-9]{3})$/;\n\tvar hex = /^#([a-fA-F0-9]{6})$/;\n\tvar rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar keyword = /(\\D+)/;\n\n\tvar rgb = [0, 0, 0, 1];\n\tvar match;\n\tvar i;\n\n\tif (match = string.match(abbr)) {\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i] + match[i], 16);\n\t\t}\n\t} else if (match = string.match(hex)) {\n\t\tmatch = match[1];\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19\n\t\t\tvar i2 = i * 2;\n\t\t\trgb[i] = parseInt(match.slice(i2, i2 + 2), 16);\n\t\t}\n\t} else if (match = string.match(rgba)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = parseInt(match[i + 1], 0);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(per)) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\trgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t\t}\n\n\t\tif (match[4]) {\n\t\t\trgb[3] = parseFloat(match[4]);\n\t\t}\n\t} else if (match = string.match(keyword)) {\n\t\tif (match[1] === 'transparent') {\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\n\t\trgb = colorNames[match[1]];\n\n\t\tif (!rgb) {\n\t\t\treturn null;\n\t\t}\n\n\t\trgb[3] = 1;\n\n\t\treturn rgb;\n\t}\n\n\tfor (i = 0; i < rgb.length; i++) {\n\t\trgb[i] = clamp(rgb[i], 0, 255);\n\t}\n\trgb[3] = clamp(rgb[3], 0, 1);\n\n\treturn rgb;\n};\n\ncs.get.hsl = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hsl = /^hsla?\\(\\s*([+-]?\\d*[\\.]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hsl);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar s = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar l = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\n\t\treturn [h, s, l, a];\n\t}\n\n\treturn null;\n};\n\ncs.get.hwb = function (string) {\n\tif (!string) {\n\t\treturn null;\n\t}\n\n\tvar hwb = /^hwb\\(\\s*([+-]?\\d*[\\.]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/;\n\tvar match = string.match(hwb);\n\n\tif (match) {\n\t\tvar alpha = parseFloat(match[4]);\n\t\tvar h = ((parseFloat(match[1]) % 360) + 360) % 360;\n\t\tvar w = clamp(parseFloat(match[2]), 0, 100);\n\t\tvar b = clamp(parseFloat(match[3]), 0, 100);\n\t\tvar a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t\treturn [h, w, b, a];\n\t}\n\n\treturn null;\n};\n\ncs.to.hex = function (rgb) {\n\treturn '#' + hexDouble(rgb[0]) + hexDouble(rgb[1]) + hexDouble(rgb[2]);\n};\n\ncs.to.rgb = function () {\n\tvar rgba = swizzle(arguments);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'\n\t\t: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';\n};\n\ncs.to.rgb.percent = function () {\n\tvar rgba = swizzle(arguments);\n\n\tvar r = Math.round(rgba[0] / 255 * 100);\n\tvar g = Math.round(rgba[1] / 255 * 100);\n\tvar b = Math.round(rgba[2] / 255 * 100);\n\n\treturn rgba.length < 4 || rgba[3] === 1\n\t\t? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'\n\t\t: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';\n};\n\ncs.to.hsl = function () {\n\tvar hsla = swizzle(arguments);\n\treturn hsla.length < 4 || hsla[3] === 1\n\t\t? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'\n\t\t: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';\n};\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\ncs.to.hwb = function () {\n\tvar hwba = swizzle(arguments);\n\n\tvar a = '';\n\tif (hwba.length >= 4 && hwba[3] !== 1) {\n\t\ta = ', ' + hwba[3];\n\t}\n\n\treturn 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';\n};\n\ncs.to.keyword = function (rgb) {\n\treturn reverseNames[rgb.slice(0, 3)];\n};\n\n// helpers\nfunction clamp(num, min, max) {\n\treturn Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n\tvar str = num.toString(16).toUpperCase();\n\treturn (str.length < 2) ? '0' + str : str;\n}\n"
    },
    {
      "id": 20,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/color/index.js",
      "name": "./~/color/index.js",
      "index": 11,
      "index2": 15,
      "size": 10907,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/header.js",
      "issuerId": 13,
      "issuerName": "./_js/header.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 13,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/header.js",
          "module": "./_js/header.js",
          "moduleName": "./_js/header.js",
          "type": "cjs require",
          "userRequest": "color",
          "loc": "3:13-29"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "'use strict';\n\nvar colorString = require('color-string');\nvar convert = require('color-convert');\n\nvar _slice = [].slice;\n\nvar skippedModels = [\n\t// to be honest, I don't really feel like keyword belongs in color convert, but eh.\n\t'keyword',\n\n\t// gray conflicts with some method names, and has its own method defined.\n\t'gray',\n\n\t// shouldn't really be in color-convert either...\n\t'hex'\n];\n\nvar hashedModelKeys = {};\nObject.keys(convert).forEach(function (model) {\n\thashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;\n});\n\nvar limiters = {};\n\nfunction Color(obj, model) {\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj, model);\n\t}\n\n\tif (model && model in skippedModels) {\n\t\tmodel = null;\n\t}\n\n\tif (model && !(model in convert)) {\n\t\tthrow new Error('Unknown model: ' + model);\n\t}\n\n\tvar i;\n\tvar channels;\n\n\tif (!obj) {\n\t\tthis.model = 'rgb';\n\t\tthis.color = [0, 0, 0];\n\t\tthis.valpha = 1;\n\t} else if (obj instanceof Color) {\n\t\tthis.model = obj.model;\n\t\tthis.color = obj.color.slice();\n\t\tthis.valpha = obj.valpha;\n\t} else if (typeof obj === 'string') {\n\t\tvar result = colorString.get(obj);\n\t\tif (result === null) {\n\t\t\tthrow new Error('Unable to parse color from string: ' + obj);\n\t\t}\n\n\t\tthis.model = result.model;\n\t\tchannels = convert[this.model].channels;\n\t\tthis.color = result.value.slice(0, channels);\n\t\tthis.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;\n\t} else if (obj.length) {\n\t\tthis.model = model || 'rgb';\n\t\tchannels = convert[this.model].channels;\n\t\tvar newArr = _slice.call(obj, 0, channels);\n\t\tthis.color = zeroArray(newArr, channels);\n\t\tthis.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;\n\t} else if (typeof obj === 'number') {\n\t\t// this is always RGB - can be converted later on.\n\t\tobj &= 0xFFFFFF;\n\t\tthis.model = 'rgb';\n\t\tthis.color = [\n\t\t\t(obj >> 16) & 0xFF,\n\t\t\t(obj >> 8) & 0xFF,\n\t\t\tobj & 0xFF\n\t\t];\n\t\tthis.valpha = 1;\n\t} else {\n\t\tthis.valpha = 1;\n\n\t\tvar keys = Object.keys(obj);\n\t\tif ('alpha' in obj) {\n\t\t\tkeys.splice(keys.indexOf('alpha'), 1);\n\t\t\tthis.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;\n\t\t}\n\n\t\tvar hashedKeys = keys.sort().join('');\n\t\tif (!(hashedKeys in hashedModelKeys)) {\n\t\t\tthrow new Error('Unable to parse color from object: ' + JSON.stringify(obj));\n\t\t}\n\n\t\tthis.model = hashedModelKeys[hashedKeys];\n\n\t\tvar labels = convert[this.model].labels;\n\t\tvar color = [];\n\t\tfor (i = 0; i < labels.length; i++) {\n\t\t\tcolor.push(obj[labels[i]]);\n\t\t}\n\n\t\tthis.color = zeroArray(color);\n\t}\n\n\t// perform limitations (clamping, etc.)\n\tif (limiters[this.model]) {\n\t\tchannels = convert[this.model].channels;\n\t\tfor (i = 0; i < channels; i++) {\n\t\t\tvar limit = limiters[this.model][i];\n\t\t\tif (limit) {\n\t\t\t\tthis.color[i] = limit(this.color[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.valpha = Math.max(0, Math.min(1, this.valpha));\n\n\tif (Object.freeze) {\n\t\tObject.freeze(this);\n\t}\n}\n\nColor.prototype = {\n\ttoString: function () {\n\t\treturn this.string();\n\t},\n\n\ttoJSON: function () {\n\t\treturn this[this.model]();\n\t},\n\n\tstring: function (places) {\n\t\tvar self = this.model in colorString.to ? this : this.rgb();\n\t\tself = self.round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to[self.model](args);\n\t},\n\n\tpercentString: function (places) {\n\t\tvar self = this.rgb().round(typeof places === 'number' ? places : 1);\n\t\tvar args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);\n\t\treturn colorString.to.rgb.percent(args);\n\t},\n\n\tarray: function () {\n\t\treturn this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);\n\t},\n\n\tobject: function () {\n\t\tvar result = {};\n\t\tvar channels = convert[this.model].channels;\n\t\tvar labels = convert[this.model].labels;\n\n\t\tfor (var i = 0; i < channels; i++) {\n\t\t\tresult[labels[i]] = this.color[i];\n\t\t}\n\n\t\tif (this.valpha !== 1) {\n\t\t\tresult.alpha = this.valpha;\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tunitArray: function () {\n\t\tvar rgb = this.rgb().color;\n\t\trgb[0] /= 255;\n\t\trgb[1] /= 255;\n\t\trgb[2] /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.push(this.valpha);\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tunitObject: function () {\n\t\tvar rgb = this.rgb().object();\n\t\trgb.r /= 255;\n\t\trgb.g /= 255;\n\t\trgb.b /= 255;\n\n\t\tif (this.valpha !== 1) {\n\t\t\trgb.alpha = this.valpha;\n\t\t}\n\n\t\treturn rgb;\n\t},\n\n\tround: function (places) {\n\t\tplaces = Math.max(places || 0, 0);\n\t\treturn new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);\n\t},\n\n\talpha: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);\n\t\t}\n\n\t\treturn this.valpha;\n\t},\n\n\t// rgb\n\tred: getset('rgb', 0, maxfn(255)),\n\tgreen: getset('rgb', 1, maxfn(255)),\n\tblue: getset('rgb', 2, maxfn(255)),\n\n\thue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style\n\n\tsaturationl: getset('hsl', 1, maxfn(100)),\n\tlightness: getset('hsl', 2, maxfn(100)),\n\n\tsaturationv: getset('hsv', 1, maxfn(100)),\n\tvalue: getset('hsv', 2, maxfn(100)),\n\n\tchroma: getset('hcg', 1, maxfn(100)),\n\tgray: getset('hcg', 2, maxfn(100)),\n\n\twhite: getset('hwb', 1, maxfn(100)),\n\twblack: getset('hwb', 2, maxfn(100)),\n\n\tcyan: getset('cmyk', 0, maxfn(100)),\n\tmagenta: getset('cmyk', 1, maxfn(100)),\n\tyellow: getset('cmyk', 2, maxfn(100)),\n\tblack: getset('cmyk', 3, maxfn(100)),\n\n\tx: getset('xyz', 0, maxfn(100)),\n\ty: getset('xyz', 1, maxfn(100)),\n\tz: getset('xyz', 2, maxfn(100)),\n\n\tl: getset('lab', 0, maxfn(100)),\n\ta: getset('lab', 1),\n\tb: getset('lab', 2),\n\n\tkeyword: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn convert[this.model].keyword(this.color);\n\t},\n\n\thex: function (val) {\n\t\tif (arguments.length) {\n\t\t\treturn new Color(val);\n\t\t}\n\n\t\treturn colorString.to.hex(this.rgb().round().color);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.rgb().color;\n\t\treturn ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.rgb().color;\n\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.rgb().color;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = this.rgb();\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb.color[i] = 255 - rgb.color[i];\n\t\t}\n\t\treturn rgb;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] += hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[2] -= hsl.color[2] * ratio;\n\t\treturn hsl;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] += hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.hsl();\n\t\thsl.color[1] -= hsl.color[1] * ratio;\n\t\treturn hsl;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[1] += hwb.color[1] * ratio;\n\t\treturn hwb;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.hwb();\n\t\thwb.color[2] += hwb.color[2] * ratio;\n\t\treturn hwb;\n\t},\n\n\tgrayscale: function () {\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar rgb = this.rgb().color;\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\treturn Color.rgb(val, val, val);\n\t},\n\n\tfade: function (ratio) {\n\t\treturn this.alpha(this.valpha - (this.valpha * ratio));\n\t},\n\n\topaquer: function (ratio) {\n\t\treturn this.alpha(this.valpha + (this.valpha * ratio));\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.hsl();\n\t\tvar hue = hsl.color[0];\n\t\thue = (hue + degrees) % 360;\n\t\thue = hue < 0 ? 360 + hue : hue;\n\t\thsl.color[0] = hue;\n\t\treturn hsl;\n\t},\n\n\tmix: function (mixinColor, weight) {\n\t\t// ported from sass implementation in C\n\t\t// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\tvar color1 = this.rgb();\n\t\tvar color2 = mixinColor.rgb();\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn Color.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue(),\n\t\t\t\tcolor1.alpha() * p + color2.alpha() * (1 - p));\n\t}\n};\n\n// model conversion methods and static constructors\nObject.keys(convert).forEach(function (model) {\n\tif (skippedModels.indexOf(model) !== -1) {\n\t\treturn;\n\t}\n\n\tvar channels = convert[model].channels;\n\n\t// conversion methods\n\tColor.prototype[model] = function () {\n\t\tif (this.model === model) {\n\t\t\treturn new Color(this);\n\t\t}\n\n\t\tif (arguments.length) {\n\t\t\treturn new Color(arguments, model);\n\t\t}\n\n\t\tvar newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;\n\t\treturn new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);\n\t};\n\n\t// 'static' construction methods\n\tColor[model] = function (color) {\n\t\tif (typeof color === 'number') {\n\t\t\tcolor = zeroArray(_slice.call(arguments), channels);\n\t\t}\n\t\treturn new Color(color, model);\n\t};\n});\n\nfunction roundTo(num, places) {\n\treturn Number(num.toFixed(places));\n}\n\nfunction roundToPlace(places) {\n\treturn function (num) {\n\t\treturn roundTo(num, places);\n\t};\n}\n\nfunction getset(model, channel, modifier) {\n\tmodel = Array.isArray(model) ? model : [model];\n\n\tmodel.forEach(function (m) {\n\t\t(limiters[m] || (limiters[m] = []))[channel] = modifier;\n\t});\n\n\tmodel = model[0];\n\n\treturn function (val) {\n\t\tvar result;\n\n\t\tif (arguments.length) {\n\t\t\tif (modifier) {\n\t\t\t\tval = modifier(val);\n\t\t\t}\n\n\t\t\tresult = this[model]();\n\t\t\tresult.color[channel] = val;\n\t\t\treturn result;\n\t\t}\n\n\t\tresult = this[model]().color[channel];\n\t\tif (modifier) {\n\t\t\tresult = modifier(result);\n\t\t}\n\n\t\treturn result;\n\t};\n}\n\nfunction maxfn(max) {\n\treturn function (v) {\n\t\treturn Math.max(0, Math.min(max, v));\n\t};\n}\n\nfunction assertArray(val) {\n\treturn Array.isArray(val) ? val : [val];\n}\n\nfunction zeroArray(arr, length) {\n\tfor (var i = 0; i < length; i++) {\n\t\tif (typeof arr[i] !== 'number') {\n\t\t\tarr[i] = 0;\n\t\t}\n\t}\n\n\treturn arr;\n}\n\nmodule.exports = Color;\n"
    },
    {
      "id": 21,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/desandro-matches-selector/matches-selector.js",
      "name": "./~/desandro-matches-selector/matches-selector.js",
      "index": 25,
      "index2": 19,
      "size": 1296,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/fizzy-ui-utils/utils.js",
      "issuerId": 0,
      "issuerName": "./~/fizzy-ui-utils/utils.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 0,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/fizzy-ui-utils/utils.js",
          "module": "./~/fizzy-ui-utils/utils.js",
          "moduleName": "./~/fizzy-ui-utils/utils.js",
          "type": "amd require",
          "userRequest": "desandro-matches-selector/matches-selector",
          "loc": "14:4-18:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 6,
      "source": "/**\n * matchesSelector v2.0.1\n * matchesSelector( element, '.selector' )\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  /*global define: false, module: false */\n  'use strict';\n  // universal module definition\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.matchesSelector = factory();\n  }\n\n}( window, function factory() {\n  'use strict';\n\n  var matchesMethod = ( function() {\n    var ElemProto = Element.prototype;\n    // check for the standard method name first\n    if ( ElemProto.matches ) {\n      return 'matches';\n    }\n    // check un-prefixed\n    if ( ElemProto.matchesSelector ) {\n      return 'matchesSelector';\n    }\n    // check vendor prefixes\n    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];\n\n    for ( var i=0; i < prefixes.length; i++ ) {\n      var prefix = prefixes[i];\n      var method = prefix + 'MatchesSelector';\n      if ( ElemProto[ method ] ) {\n        return method;\n      }\n    }\n  })();\n\n  return function matchesSelector( elem, selector ) {\n    return elem[ matchesMethod ]( selector );\n  };\n\n}));\n"
    },
    {
      "id": 22,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/add-remove-cell.js",
      "name": "./~/flickity/js/add-remove-cell.js",
      "index": 36,
      "index2": 32,
      "size": 4905,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./add-remove-cell",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// add, remove cell\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'fizzy-ui-utils/utils'\n    ], function( Flickity, utils ) {\n      return factory( window, Flickity, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('./flickity'),\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    factory(\n      window,\n      window.Flickity,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, utils ) {\n\n'use strict';\n\n// append cells to a document fragment\nfunction getCellsFragment( cells ) {\n  var fragment = document.createDocumentFragment();\n  cells.forEach( function( cell ) {\n    fragment.appendChild( cell.element );\n  });\n  return fragment;\n}\n\n// -------------------------- add/remove cell prototype -------------------------- //\n\nvar proto = Flickity.prototype;\n\n/**\n * Insert, prepend, or append cells\n * @param {Element, Array, NodeList} elems\n * @param {Integer} index\n */\nproto.insert = function( elems, index ) {\n  var cells = this._makeCells( elems );\n  if ( !cells || !cells.length ) {\n    return;\n  }\n  var len = this.cells.length;\n  // default to append\n  index = index === undefined ? len : index;\n  // add cells with document fragment\n  var fragment = getCellsFragment( cells );\n  // append to slider\n  var isAppend = index == len;\n  if ( isAppend ) {\n    this.slider.appendChild( fragment );\n  } else {\n    var insertCellElement = this.cells[ index ].element;\n    this.slider.insertBefore( fragment, insertCellElement );\n  }\n  // add to this.cells\n  if ( index === 0 ) {\n    // prepend, add to start\n    this.cells = cells.concat( this.cells );\n  } else if ( isAppend ) {\n    // append, add to end\n    this.cells = this.cells.concat( cells );\n  } else {\n    // insert in this.cells\n    var endCells = this.cells.splice( index, len - index );\n    this.cells = this.cells.concat( cells ).concat( endCells );\n  }\n\n  this._sizeCells( cells );\n\n  var selectedIndexDelta = index > this.selectedIndex ? 0 : cells.length;\n  this._cellAddedRemoved( index, selectedIndexDelta );\n};\n\nproto.append = function( elems ) {\n  this.insert( elems, this.cells.length );\n};\n\nproto.prepend = function( elems ) {\n  this.insert( elems, 0 );\n};\n\n/**\n * Remove cells\n * @param {Element, Array, NodeList} elems\n */\nproto.remove = function( elems ) {\n  var cells = this.getCells( elems );\n  var selectedIndexDelta = 0;\n  var len = cells.length;\n  var i, cell;\n  // calculate selectedIndexDelta, easier if done in seperate loop\n  for ( i=0; i < len; i++ ) {\n    cell = cells[i];\n    var wasBefore = this.cells.indexOf( cell ) < this.selectedIndex;\n    selectedIndexDelta -= wasBefore ? 1 : 0;\n  }\n\n  for ( i=0; i < len; i++ ) {\n    cell = cells[i];\n    cell.remove();\n    // remove item from collection\n    utils.removeFrom( this.cells, cell );\n  }\n\n  if ( cells.length ) {\n    // update stuff\n    this._cellAddedRemoved( 0, selectedIndexDelta );\n  }\n};\n\n// updates when cells are added or removed\nproto._cellAddedRemoved = function( changedCellIndex, selectedIndexDelta ) {\n  // TODO this math isn't perfect with grouped slides\n  selectedIndexDelta = selectedIndexDelta || 0;\n  this.selectedIndex += selectedIndexDelta;\n  this.selectedIndex = Math.max( 0, Math.min( this.slides.length - 1, this.selectedIndex ) );\n\n  this.cellChange( changedCellIndex, true );\n  // backwards compatibility\n  this.emitEvent( 'cellAddedRemoved', [ changedCellIndex, selectedIndexDelta ] );\n};\n\n/**\n * logic to be run after a cell's size changes\n * @param {Element} elem - cell's element\n */\nproto.cellSizeChange = function( elem ) {\n  var cell = this.getCell( elem );\n  if ( !cell ) {\n    return;\n  }\n  cell.getSize();\n\n  var index = this.cells.indexOf( cell );\n  this.cellChange( index );\n};\n\n/**\n * logic any time a cell is changed: added, removed, or size changed\n * @param {Integer} changedCellIndex - index of the changed cell, optional\n */\nproto.cellChange = function( changedCellIndex, isPositioningSlider ) {\n  var prevSlideableWidth = this.slideableWidth;\n  this._positionCells( changedCellIndex );\n  this._getWrapShiftCells();\n  this.setGallerySize();\n  this.emitEvent( 'cellChange', [ changedCellIndex ] );\n  // position slider\n  if ( this.options.freeScroll ) {\n    // shift x by change in slideableWidth\n    // TODO fix position shifts when prepending w/ freeScroll\n    var deltaX = prevSlideableWidth - this.slideableWidth;\n    this.x += deltaX * this.cellAlign;\n    this.positionSlider();\n  } else {\n    // do not position slider after lazy load\n    if ( isPositioningSlider ) {\n      this.positionSliderAtSelected();\n    }\n    this.select( this.selectedIndex );\n  }\n};\n\n// -----  ----- //\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 23,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/animate.js",
      "name": "./~/flickity/js/animate.js",
      "index": 28,
      "index2": 23,
      "size": 5865,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "./animate",
          "loc": "7:4-16:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "// animate\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'fizzy-ui-utils/utils'\n    ], function( utils ) {\n      return factory( window, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.animatePrototype = factory(\n      window,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, utils ) {\n\n'use strict';\n\n// -------------------------- requestAnimationFrame -------------------------- //\n\n// get rAF, prefixed, if present\nvar requestAnimationFrame = window.requestAnimationFrame ||\n  window.webkitRequestAnimationFrame;\n\n// fallback to setTimeout\nvar lastTime = 0;\nif ( !requestAnimationFrame )  {\n  requestAnimationFrame = function( callback ) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n    var id = setTimeout( callback, timeToCall );\n    lastTime = currTime + timeToCall;\n    return id;\n  };\n}\n\n// -------------------------- animate -------------------------- //\n\nvar proto = {};\n\nproto.startAnimation = function() {\n  if ( this.isAnimating ) {\n    return;\n  }\n\n  this.isAnimating = true;\n  this.restingFrames = 0;\n  this.animate();\n};\n\nproto.animate = function() {\n  this.applyDragForce();\n  this.applySelectedAttraction();\n\n  var previousX = this.x;\n\n  this.integratePhysics();\n  this.positionSlider();\n  this.settle( previousX );\n  // animate next frame\n  if ( this.isAnimating ) {\n    var _this = this;\n    requestAnimationFrame( function animateFrame() {\n      _this.animate();\n    });\n  }\n};\n\n\nvar transformProperty = ( function () {\n  var style = document.documentElement.style;\n  if ( typeof style.transform == 'string' ) {\n    return 'transform';\n  }\n  return 'WebkitTransform';\n})();\n\nproto.positionSlider = function() {\n  var x = this.x;\n  // wrap position around\n  if ( this.options.wrapAround && this.cells.length > 1 ) {\n    x = utils.modulo( x, this.slideableWidth );\n    x = x - this.slideableWidth;\n    this.shiftWrapCells( x );\n  }\n\n  x = x + this.cursorPosition;\n  // reverse if right-to-left and using transform\n  x = this.options.rightToLeft && transformProperty ? -x : x;\n  var value = this.getPositionValue( x );\n  // use 3D tranforms for hardware acceleration on iOS\n  // but use 2D when settled, for better font-rendering\n  this.slider.style[ transformProperty ] = this.isAnimating ?\n    'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';\n\n  // scroll event\n  var firstSlide = this.slides[0];\n  if ( firstSlide ) {\n    var positionX = -this.x - firstSlide.target;\n    var progress = positionX / this.slidesWidth;\n    this.dispatchEvent( 'scroll', null, [ progress, positionX ] );\n  }\n};\n\nproto.positionSliderAtSelected = function() {\n  if ( !this.cells.length ) {\n    return;\n  }\n  this.x = -this.selectedSlide.target;\n  this.positionSlider();\n};\n\nproto.getPositionValue = function( position ) {\n  if ( this.options.percentPosition ) {\n    // percent position, round to 2 digits, like 12.34%\n    return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 )+ '%';\n  } else {\n    // pixel positioning\n    return Math.round( position ) + 'px';\n  }\n};\n\nproto.settle = function( previousX ) {\n  // keep track of frames where x hasn't moved\n  if ( !this.isPointerDown && Math.round( this.x * 100 ) == Math.round( previousX * 100 ) ) {\n    this.restingFrames++;\n  }\n  // stop animating if resting for 3 or more frames\n  if ( this.restingFrames > 2 ) {\n    this.isAnimating = false;\n    delete this.isFreeScrolling;\n    // render position with translateX when settled\n    this.positionSlider();\n    this.dispatchEvent('settle');\n  }\n};\n\nproto.shiftWrapCells = function( x ) {\n  // shift before cells\n  var beforeGap = this.cursorPosition + x;\n  this._shiftCells( this.beforeShiftCells, beforeGap, -1 );\n  // shift after cells\n  var afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );\n  this._shiftCells( this.afterShiftCells, afterGap, 1 );\n};\n\nproto._shiftCells = function( cells, gap, shift ) {\n  for ( var i=0; i < cells.length; i++ ) {\n    var cell = cells[i];\n    var cellShift = gap > 0 ? shift : 0;\n    cell.wrapShift( cellShift );\n    gap -= cell.size.outerWidth;\n  }\n};\n\nproto._unshiftCells = function( cells ) {\n  if ( !cells || !cells.length ) {\n    return;\n  }\n  for ( var i=0; i < cells.length; i++ ) {\n    cells[i].wrapShift( 0 );\n  }\n};\n\n// -------------------------- physics -------------------------- //\n\nproto.integratePhysics = function() {\n  this.x += this.velocity;\n  this.velocity *= this.getFrictionFactor();\n};\n\nproto.applyForce = function( force ) {\n  this.velocity += force;\n};\n\nproto.getFrictionFactor = function() {\n  return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];\n};\n\nproto.getRestingPosition = function() {\n  // my thanks to Steven Wittens, who simplified this math greatly\n  return this.x + this.velocity / ( 1 - this.getFrictionFactor() );\n};\n\nproto.applyDragForce = function() {\n  if ( !this.isPointerDown ) {\n    return;\n  }\n  // change the position to drag position by applying force\n  var dragVelocity = this.dragX - this.x;\n  var dragForce = dragVelocity - this.velocity;\n  this.applyForce( dragForce );\n};\n\nproto.applySelectedAttraction = function() {\n  // do not attract if pointer down or no cells\n  if ( this.isPointerDown || this.isFreeScrolling || !this.cells.length ) {\n    return;\n  }\n  var distance = this.selectedSlide.target * -1 - this.x;\n  var force = distance * this.options.selectedAttraction;\n  this.applyForce( force );\n};\n\nreturn proto;\n\n}));\n"
    },
    {
      "id": 24,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/cell.js",
      "name": "./~/flickity/js/cell.js",
      "index": 26,
      "index2": 21,
      "size": 2045,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "./cell",
          "loc": "7:4-16:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "// Flickity.Cell\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'get-size/get-size'\n    ], function( getSize ) {\n      return factory( window, getSize );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('get-size')\n    );\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.Cell = factory(\n      window,\n      window.getSize\n    );\n  }\n\n}( window, function factory( window, getSize ) {\n\n'use strict';\n\nfunction Cell( elem, parent ) {\n  this.element = elem;\n  this.parent = parent;\n\n  this.create();\n}\n\nvar proto = Cell.prototype;\n\nproto.create = function() {\n  this.element.style.position = 'absolute';\n  this.x = 0;\n  this.shift = 0;\n};\n\nproto.destroy = function() {\n  // reset style\n  this.element.style.position = '';\n  var side = this.parent.originSide;\n  this.element.style[ side ] = '';\n};\n\nproto.getSize = function() {\n  this.size = getSize( this.element );\n};\n\nproto.setPosition = function( x ) {\n  this.x = x;\n  this.updateTarget();\n  this.renderPosition( x );\n};\n\n// setDefaultTarget v1 method, backwards compatibility, remove in v3\nproto.updateTarget = proto.setDefaultTarget = function() {\n  var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';\n  this.target = this.x + this.size[ marginProperty ] +\n    this.size.width * this.parent.cellAlign;\n};\n\nproto.renderPosition = function( x ) {\n  // render position of cell with in slider\n  var side = this.parent.originSide;\n  this.element.style[ side ] = this.parent.getPositionValue( x );\n};\n\n/**\n * @param {Integer} factor - 0, 1, or -1\n**/\nproto.wrapShift = function( shift ) {\n  this.shift = shift;\n  this.renderPosition( this.x + this.parent.slideableWidth * shift );\n};\n\nproto.remove = function() {\n  this.element.parentNode.removeChild( this.element );\n};\n\nreturn Cell;\n\n}));\n"
    },
    {
      "id": 25,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/drag.js",
      "name": "./~/flickity/js/drag.js",
      "index": 29,
      "index2": 27,
      "size": 11389,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./drag",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// drag\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'unidragger/unidragger',\n      'fizzy-ui-utils/utils'\n    ], function( Flickity, Unidragger, utils ) {\n      return factory( window, Flickity, Unidragger, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('./flickity'),\n      require('unidragger'),\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    window.Flickity = factory(\n      window,\n      window.Flickity,\n      window.Unidragger,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, Unidragger, utils ) {\n\n'use strict';\n\n// ----- defaults ----- //\n\nutils.extend( Flickity.defaults, {\n  draggable: true,\n  dragThreshold: 3,\n});\n\n// ----- create ----- //\n\nFlickity.createMethods.push('_createDrag');\n\n// -------------------------- drag prototype -------------------------- //\n\nvar proto = Flickity.prototype;\nutils.extend( proto, Unidragger.prototype );\n\n// --------------------------  -------------------------- //\n\nvar isTouch = 'createTouch' in document;\nvar isTouchmoveScrollCanceled = false;\n\nproto._createDrag = function() {\n  this.on( 'activate', this.bindDrag );\n  this.on( 'uiChange', this._uiChangeDrag );\n  this.on( 'childUIPointerDown', this._childUIPointerDownDrag );\n  this.on( 'deactivate', this.unbindDrag );\n  // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior\n  // #457, RubaXa/Sortable#973\n  if ( isTouch && !isTouchmoveScrollCanceled ) {\n    window.addEventListener( 'touchmove', function() {});\n    isTouchmoveScrollCanceled = true;\n  }\n};\n\nproto.bindDrag = function() {\n  if ( !this.options.draggable || this.isDragBound ) {\n    return;\n  }\n  this.element.classList.add('is-draggable');\n  this.handles = [ this.viewport ];\n  this.bindHandles();\n  this.isDragBound = true;\n};\n\nproto.unbindDrag = function() {\n  if ( !this.isDragBound ) {\n    return;\n  }\n  this.element.classList.remove('is-draggable');\n  this.unbindHandles();\n  delete this.isDragBound;\n};\n\nproto._uiChangeDrag = function() {\n  delete this.isFreeScrolling;\n};\n\nproto._childUIPointerDownDrag = function( event ) {\n  event.preventDefault();\n  this.pointerDownFocus( event );\n};\n\n// -------------------------- pointer events -------------------------- //\n\n// nodes that have text fields\nvar cursorNodes = {\n  TEXTAREA: true,\n  INPUT: true,\n  OPTION: true,\n};\n\n// input types that do not have text fields\nvar clickTypes = {\n  radio: true,\n  checkbox: true,\n  button: true,\n  submit: true,\n  image: true,\n  file: true,\n};\n\nproto.pointerDown = function( event, pointer ) {\n  // dismiss inputs with text fields. #403, #404\n  var isCursorInput = cursorNodes[ event.target.nodeName ] &&\n    !clickTypes[ event.target.type ];\n  if ( isCursorInput ) {\n    // reset pointerDown logic\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n    return;\n  }\n\n  this._dragPointerDown( event, pointer );\n\n  // kludge to blur focused inputs in dragger\n  var focused = document.activeElement;\n  if ( focused && focused.blur && focused != this.element &&\n    // do not blur body for IE9 & 10, #117\n    focused != document.body ) {\n    focused.blur();\n  }\n  this.pointerDownFocus( event );\n  // stop if it was moving\n  this.dragX = this.x;\n  this.viewport.classList.add('is-pointer-down');\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  // track scrolling\n  this.pointerDownScroll = getScrollPosition();\n  window.addEventListener( 'scroll', this );\n\n  this.dispatchEvent( 'pointerDown', event, [ pointer ] );\n};\n\nvar touchStartEvents = {\n  touchstart: true,\n  MSPointerDown: true\n};\n\nvar focusNodes = {\n  INPUT: true,\n  SELECT: true\n};\n\nproto.pointerDownFocus = function( event ) {\n  // focus element, if not touch, and its not an input or select\n  if ( !this.options.accessibility || touchStartEvents[ event.type ] ||\n      focusNodes[ event.target.nodeName ] ) {\n    return;\n  }\n  var prevScrollY = window.pageYOffset;\n  this.element.focus();\n  // hack to fix scroll jump after focus, #76\n  if ( window.pageYOffset != prevScrollY ) {\n    window.scrollTo( window.pageXOffset, prevScrollY );\n  }\n};\n\nproto.canPreventDefaultOnPointerDown = function( event ) {\n  // prevent default, unless touchstart or <select>\n  var isTouchstart = event.type == 'touchstart';\n  var targetNodeName = event.target.nodeName;\n  return !isTouchstart && targetNodeName != 'SELECT';\n};\n\n// ----- move ----- //\n\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > this.options.dragThreshold;\n};\n\n// ----- up ----- //\n\nproto.pointerUp = function( event, pointer ) {\n  delete this.isTouchScrolling;\n  this.viewport.classList.remove('is-pointer-down');\n  this.dispatchEvent( 'pointerUp', event, [ pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto.pointerDone = function() {\n  window.removeEventListener( 'scroll', this );\n  delete this.pointerDownScroll;\n};\n\n// -------------------------- dragging -------------------------- //\n\nproto.dragStart = function( event, pointer ) {\n  this.dragStartPosition = this.x;\n  this.startAnimation();\n  window.removeEventListener( 'scroll', this );\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n};\n\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n\n  this.previousDragX = this.dragX;\n  // reverse if right-to-left\n  var direction = this.options.rightToLeft ? -1 : 1;\n  var dragX = this.dragStartPosition + moveVector.x * direction;\n\n  if ( !this.options.wrapAround && this.slides.length ) {\n    // slow drag\n    var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );\n    dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;\n    var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );\n    dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;\n  }\n\n  this.dragX = dragX;\n\n  this.dragMoveTime = new Date();\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  if ( this.options.freeScroll ) {\n    this.isFreeScrolling = true;\n  }\n  // set selectedIndex based on where flick will end up\n  var index = this.dragEndRestingSelect();\n\n  if ( this.options.freeScroll && !this.options.wrapAround ) {\n    // if free-scroll & not wrap around\n    // do not free-scroll if going outside of bounding slides\n    // so bounding slides can attract slider, and keep it in bounds\n    var restingX = this.getRestingPosition();\n    this.isFreeScrolling = -restingX > this.slides[0].target &&\n      -restingX < this.getLastSlide().target;\n  } else if ( !this.options.freeScroll && index == this.selectedIndex ) {\n    // boost selection if selected index has not changed\n    index += this.dragEndBoostSelect();\n  }\n  delete this.previousDragX;\n  // apply selection\n  // TODO refactor this, selecting here feels weird\n  // HACK, set flag so dragging stays in correct direction\n  this.isDragSelect = this.options.wrapAround;\n  this.select( index );\n  delete this.isDragSelect;\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\nproto.dragEndRestingSelect = function() {\n  var restingX = this.getRestingPosition();\n  // how far away from selected slide\n  var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );\n  // get closet resting going up and going down\n  var positiveResting = this._getClosestResting( restingX, distance, 1 );\n  var negativeResting = this._getClosestResting( restingX, distance, -1 );\n  // use closer resting for wrap-around\n  var index = positiveResting.distance < negativeResting.distance ?\n    positiveResting.index : negativeResting.index;\n  return index;\n};\n\n/**\n * given resting X and distance to selected cell\n * get the distance and index of the closest cell\n * @param {Number} restingX - estimated post-flick resting position\n * @param {Number} distance - distance to selected cell\n * @param {Integer} increment - +1 or -1, going up or down\n * @returns {Object} - { distance: {Number}, index: {Integer} }\n */\nproto._getClosestResting = function( restingX, distance, increment ) {\n  var index = this.selectedIndex;\n  var minDistance = Infinity;\n  var condition = this.options.contain && !this.options.wrapAround ?\n    // if contain, keep going if distance is equal to minDistance\n    function( d, md ) { return d <= md; } : function( d, md ) { return d < md; };\n  while ( condition( distance, minDistance ) ) {\n    // measure distance to next cell\n    index += increment;\n    minDistance = distance;\n    distance = this.getSlideDistance( -restingX, index );\n    if ( distance === null ) {\n      break;\n    }\n    distance = Math.abs( distance );\n  }\n  return {\n    distance: minDistance,\n    // selected was previous index\n    index: index - increment\n  };\n};\n\n/**\n * measure distance between x and a slide target\n * @param {Number} x\n * @param {Integer} index - slide index\n */\nproto.getSlideDistance = function( x, index ) {\n  var len = this.slides.length;\n  // wrap around if at least 2 slides\n  var isWrapAround = this.options.wrapAround && len > 1;\n  var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;\n  var slide = this.slides[ slideIndex ];\n  if ( !slide ) {\n    return null;\n  }\n  // add distance for wrap-around slides\n  var wrap = isWrapAround ? this.slideableWidth * Math.floor( index / len ) : 0;\n  return x - ( slide.target + wrap );\n};\n\nproto.dragEndBoostSelect = function() {\n  // do not boost if no previousDragX or dragMoveTime\n  if ( this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100 ) {\n    return 0;\n  }\n\n  var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );\n  var delta = this.previousDragX - this.dragX;\n  if ( distance > 0 && delta > 0 ) {\n    // boost to next if moving towards the right, and positive velocity\n    return 1;\n  } else if ( distance < 0 && delta < 0 ) {\n    // boost to previous if moving towards the left, and negative velocity\n    return -1;\n  }\n  return 0;\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  // get clickedCell, if cell was clicked\n  var clickedCell = this.getParentCell( event.target );\n  var cellElem = clickedCell && clickedCell.element;\n  var cellIndex = clickedCell && this.cells.indexOf( clickedCell );\n  this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );\n};\n\n// ----- scroll ----- //\n\nproto.onscroll = function() {\n  var scroll = getScrollPosition();\n  var scrollMoveX = this.pointerDownScroll.x - scroll.x;\n  var scrollMoveY = this.pointerDownScroll.y - scroll.y;\n  // cancel click/tap if scroll is too much\n  if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {\n    this._pointerDone();\n  }\n};\n\n// ----- utils ----- //\n\nfunction getScrollPosition() {\n  return {\n    x: window.pageXOffset,\n    y: window.pageYOffset\n  };\n}\n\n// -----  ----- //\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 26,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "name": "./~/flickity/js/index.js",
      "index": 20,
      "index2": 34,
      "size": 991,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/hero.js",
      "issuerId": 14,
      "issuerName": "./_js/hero.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 14,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/hero.js",
          "module": "./_js/hero.js",
          "moduleName": "./_js/hero.js",
          "type": "cjs require",
          "userRequest": "flickity",
          "loc": "3:16-35"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "/*!\n * Flickity v2.0.5\n * Touch, responsive, flickable carousels\n *\n * Licensed GPLv3 for open source use\n * or Flickity Commercial License for commercial use\n *\n * http://flickity.metafizzy.co\n * Copyright 2016 Metafizzy\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      './drag',\n      './prev-next-button',\n      './page-dots',\n      './player',\n      './add-remove-cell',\n      './lazyload'\n    ], factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('./flickity'),\n      require('./drag'),\n      require('./prev-next-button'),\n      require('./page-dots'),\n      require('./player'),\n      require('./add-remove-cell'),\n      require('./lazyload')\n    );\n  }\n\n})( window, function factory( Flickity ) {\n  /*jshint strict: false*/\n  return Flickity;\n});\n"
    },
    {
      "id": 27,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/lazyload.js",
      "name": "./~/flickity/js/lazyload.js",
      "index": 37,
      "index2": 33,
      "size": 3105,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./lazyload",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// lazyload\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'fizzy-ui-utils/utils'\n    ], function( Flickity, utils ) {\n      return factory( window, Flickity, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('./flickity'),\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    factory(\n      window,\n      window.Flickity,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, utils ) {\n'use strict';\n\nFlickity.createMethods.push('_createLazyload');\nvar proto = Flickity.prototype;\n\nproto._createLazyload = function() {\n  this.on( 'select', this.lazyLoad );\n};\n\nproto.lazyLoad = function() {\n  var lazyLoad = this.options.lazyLoad;\n  if ( !lazyLoad ) {\n    return;\n  }\n  // get adjacent cells, use lazyLoad option for adjacent count\n  var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;\n  var cellElems = this.getAdjacentCellElements( adjCount );\n  // get lazy images in those cells\n  var lazyImages = [];\n  cellElems.forEach( function( cellElem ) {\n    var lazyCellImages = getCellLazyImages( cellElem );\n    lazyImages = lazyImages.concat( lazyCellImages );\n  });\n  // load lazy images\n  lazyImages.forEach( function( img ) {\n    new LazyLoader( img, this );\n  }, this );\n};\n\nfunction getCellLazyImages( cellElem ) {\n  // check if cell element is lazy image\n  if ( cellElem.nodeName == 'IMG' &&\n    cellElem.getAttribute('data-flickity-lazyload') ) {\n    return [ cellElem ];\n  }\n  // select lazy images in cell\n  var imgs = cellElem.querySelectorAll('img[data-flickity-lazyload]');\n  return utils.makeArray( imgs );\n}\n\n// -------------------------- LazyLoader -------------------------- //\n\n/**\n * class to handle loading images\n */\nfunction LazyLoader( img, flickity ) {\n  this.img = img;\n  this.flickity = flickity;\n  this.load();\n}\n\nLazyLoader.prototype.handleEvent = utils.handleEvent;\n\nLazyLoader.prototype.load = function() {\n  this.img.addEventListener( 'load', this );\n  this.img.addEventListener( 'error', this );\n  // load image\n  this.img.src = this.img.getAttribute('data-flickity-lazyload');\n  // remove attr\n  this.img.removeAttribute('data-flickity-lazyload');\n};\n\nLazyLoader.prototype.onload = function( event ) {\n  this.complete( event, 'flickity-lazyloaded' );\n};\n\nLazyLoader.prototype.onerror = function( event ) {\n  this.complete( event, 'flickity-lazyerror' );\n};\n\nLazyLoader.prototype.complete = function( event, className ) {\n  // unbind events\n  this.img.removeEventListener( 'load', this );\n  this.img.removeEventListener( 'error', this );\n\n  var cell = this.flickity.getParentCell( this.img );\n  var cellElem = cell && cell.element;\n  this.flickity.cellSizeChange( cellElem );\n\n  this.img.classList.add( className );\n  this.flickity.dispatchEvent( 'lazyLoad', event, cellElem );\n};\n\n// -----  ----- //\n\nFlickity.LazyLoader = LazyLoader;\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 28,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/page-dots.js",
      "name": "./~/flickity/js/page-dots.js",
      "index": 34,
      "index2": 30,
      "size": 4307,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./page-dots",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// page dots\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'tap-listener/tap-listener',\n      'fizzy-ui-utils/utils'\n    ], function( Flickity, TapListener, utils ) {\n      return factory( window, Flickity, TapListener, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('./flickity'),\n      require('tap-listener'),\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    factory(\n      window,\n      window.Flickity,\n      window.TapListener,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, TapListener, utils ) {\n\n// -------------------------- PageDots -------------------------- //\n\n'use strict';\n\nfunction PageDots( parent ) {\n  this.parent = parent;\n  this._create();\n}\n\nPageDots.prototype = new TapListener();\n\nPageDots.prototype._create = function() {\n  // create holder element\n  this.holder = document.createElement('ol');\n  this.holder.className = 'flickity-page-dots';\n  // create dots, array of elements\n  this.dots = [];\n  // events\n  this.on( 'tap', this.onTap );\n  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );\n};\n\nPageDots.prototype.activate = function() {\n  this.setDots();\n  this.bindTap( this.holder );\n  // add to DOM\n  this.parent.element.appendChild( this.holder );\n};\n\nPageDots.prototype.deactivate = function() {\n  // remove from DOM\n  this.parent.element.removeChild( this.holder );\n  TapListener.prototype.destroy.call( this );\n};\n\nPageDots.prototype.setDots = function() {\n  // get difference between number of slides and number of dots\n  var delta = this.parent.slides.length - this.dots.length;\n  if ( delta > 0 ) {\n    this.addDots( delta );\n  } else if ( delta < 0 ) {\n    this.removeDots( -delta );\n  }\n};\n\nPageDots.prototype.addDots = function( count ) {\n  var fragment = document.createDocumentFragment();\n  var newDots = [];\n  while ( count ) {\n    var dot = document.createElement('li');\n    dot.className = 'dot';\n    fragment.appendChild( dot );\n    newDots.push( dot );\n    count--;\n  }\n  this.holder.appendChild( fragment );\n  this.dots = this.dots.concat( newDots );\n};\n\nPageDots.prototype.removeDots = function( count ) {\n  // remove from this.dots collection\n  var removeDots = this.dots.splice( this.dots.length - count, count );\n  // remove from DOM\n  removeDots.forEach( function( dot ) {\n    this.holder.removeChild( dot );\n  }, this );\n};\n\nPageDots.prototype.updateSelected = function() {\n  // remove selected class on previous\n  if ( this.selectedDot ) {\n    this.selectedDot.className = 'dot';\n  }\n  // don't proceed if no dots\n  if ( !this.dots.length ) {\n    return;\n  }\n  this.selectedDot = this.dots[ this.parent.selectedIndex ];\n  this.selectedDot.className = 'dot is-selected';\n};\n\nPageDots.prototype.onTap = function( event ) {\n  var target = event.target;\n  // only care about dot clicks\n  if ( target.nodeName != 'LI' ) {\n    return;\n  }\n\n  this.parent.uiChange();\n  var index = this.dots.indexOf( target );\n  this.parent.select( index );\n};\n\nPageDots.prototype.destroy = function() {\n  this.deactivate();\n};\n\nFlickity.PageDots = PageDots;\n\n// -------------------------- Flickity -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  pageDots: true\n});\n\nFlickity.createMethods.push('_createPageDots');\n\nvar proto = Flickity.prototype;\n\nproto._createPageDots = function() {\n  if ( !this.options.pageDots ) {\n    return;\n  }\n  this.pageDots = new PageDots( this );\n  // events\n  this.on( 'activate', this.activatePageDots );\n  this.on( 'select', this.updateSelectedPageDots );\n  this.on( 'cellChange', this.updatePageDots );\n  this.on( 'resize', this.updatePageDots );\n  this.on( 'deactivate', this.deactivatePageDots );\n};\n\nproto.activatePageDots = function() {\n  this.pageDots.activate();\n};\n\nproto.updateSelectedPageDots = function() {\n  this.pageDots.updateSelected();\n};\n\nproto.updatePageDots = function() {\n  this.pageDots.setDots();\n};\n\nproto.deactivatePageDots = function() {\n  this.pageDots.deactivate();\n};\n\n// -----  ----- //\n\nFlickity.PageDots = PageDots;\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 29,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/player.js",
      "name": "./~/flickity/js/player.js",
      "index": 35,
      "index2": 31,
      "size": 5137,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./player",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// player & autoPlay\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'ev-emitter/ev-emitter',\n      'fizzy-ui-utils/utils',\n      './flickity'\n    ], function( EvEmitter, utils, Flickity ) {\n      return factory( EvEmitter, utils, Flickity );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('ev-emitter'),\n      require('fizzy-ui-utils'),\n      require('./flickity')\n    );\n  } else {\n    // browser global\n    factory(\n      window.EvEmitter,\n      window.fizzyUIUtils,\n      window.Flickity\n    );\n  }\n\n}( window, function factory( EvEmitter, utils, Flickity ) {\n\n'use strict';\n\n// -------------------------- Page Visibility -------------------------- //\n// https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API\n\nvar hiddenProperty, visibilityEvent;\nif ( 'hidden' in document ) {\n  hiddenProperty = 'hidden';\n  visibilityEvent = 'visibilitychange';\n} else if ( 'webkitHidden' in document ) {\n  hiddenProperty = 'webkitHidden';\n  visibilityEvent = 'webkitvisibilitychange';\n}\n\n// -------------------------- Player -------------------------- //\n\nfunction Player( parent ) {\n  this.parent = parent;\n  this.state = 'stopped';\n  // visibility change event handler\n  if ( visibilityEvent ) {\n    this.onVisibilityChange = function() {\n      this.visibilityChange();\n    }.bind( this );\n    this.onVisibilityPlay = function() {\n      this.visibilityPlay();\n    }.bind( this );\n  }\n}\n\nPlayer.prototype = Object.create( EvEmitter.prototype );\n\n// start play\nPlayer.prototype.play = function() {\n  if ( this.state == 'playing' ) {\n    return;\n  }\n  // do not play if page is hidden, start playing when page is visible\n  var isPageHidden = document[ hiddenProperty ];\n  if ( visibilityEvent && isPageHidden ) {\n    document.addEventListener( visibilityEvent, this.onVisibilityPlay );\n    return;\n  }\n\n  this.state = 'playing';\n  // listen to visibility change\n  if ( visibilityEvent ) {\n    document.addEventListener( visibilityEvent, this.onVisibilityChange );\n  }\n  // start ticking\n  this.tick();\n};\n\nPlayer.prototype.tick = function() {\n  // do not tick if not playing\n  if ( this.state != 'playing' ) {\n    return;\n  }\n\n  var time = this.parent.options.autoPlay;\n  // default to 3 seconds\n  time = typeof time == 'number' ? time : 3000;\n  var _this = this;\n  // HACK: reset ticks if stopped and started within interval\n  this.clear();\n  this.timeout = setTimeout( function() {\n    _this.parent.next( true );\n    _this.tick();\n  }, time );\n};\n\nPlayer.prototype.stop = function() {\n  this.state = 'stopped';\n  this.clear();\n  // remove visibility change event\n  if ( visibilityEvent ) {\n    document.removeEventListener( visibilityEvent, this.onVisibilityChange );\n  }\n};\n\nPlayer.prototype.clear = function() {\n  clearTimeout( this.timeout );\n};\n\nPlayer.prototype.pause = function() {\n  if ( this.state == 'playing' ) {\n    this.state = 'paused';\n    this.clear();\n  }\n};\n\nPlayer.prototype.unpause = function() {\n  // re-start play if paused\n  if ( this.state == 'paused' ) {\n    this.play();\n  }\n};\n\n// pause if page visibility is hidden, unpause if visible\nPlayer.prototype.visibilityChange = function() {\n  var isPageHidden = document[ hiddenProperty ];\n  this[ isPageHidden ? 'pause' : 'unpause' ]();\n};\n\nPlayer.prototype.visibilityPlay = function() {\n  this.play();\n  document.removeEventListener( visibilityEvent, this.onVisibilityPlay );\n};\n\n// -------------------------- Flickity -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  pauseAutoPlayOnHover: true\n});\n\nFlickity.createMethods.push('_createPlayer');\nvar proto = Flickity.prototype;\n\nproto._createPlayer = function() {\n  this.player = new Player( this );\n\n  this.on( 'activate', this.activatePlayer );\n  this.on( 'uiChange', this.stopPlayer );\n  this.on( 'pointerDown', this.stopPlayer );\n  this.on( 'deactivate', this.deactivatePlayer );\n};\n\nproto.activatePlayer = function() {\n  if ( !this.options.autoPlay ) {\n    return;\n  }\n  this.player.play();\n  this.element.addEventListener( 'mouseenter', this );\n};\n\n// Player API, don't hate the ... thanks I know where the door is\n\nproto.playPlayer = function() {\n  this.player.play();\n};\n\nproto.stopPlayer = function() {\n  this.player.stop();\n};\n\nproto.pausePlayer = function() {\n  this.player.pause();\n};\n\nproto.unpausePlayer = function() {\n  this.player.unpause();\n};\n\nproto.deactivatePlayer = function() {\n  this.player.stop();\n  this.element.removeEventListener( 'mouseenter', this );\n};\n\n// ----- mouseenter/leave ----- //\n\n// pause auto-play on hover\nproto.onmouseenter = function() {\n  if ( !this.options.pauseAutoPlayOnHover ) {\n    return;\n  }\n  this.player.pause();\n  this.element.addEventListener( 'mouseleave', this );\n};\n\n// resume auto-play on hover off\nproto.onmouseleave = function() {\n  this.player.unpause();\n  this.element.removeEventListener( 'mouseleave', this );\n};\n\n// -----  ----- //\n\nFlickity.Player = Player;\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 30,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/prev-next-button.js",
      "name": "./~/flickity/js/prev-next-button.js",
      "index": 32,
      "index2": 29,
      "size": 5998,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
      "issuerId": 26,
      "issuerName": "./~/flickity/js/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 26,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/index.js",
          "module": "./~/flickity/js/index.js",
          "moduleName": "./~/flickity/js/index.js",
          "type": "amd require",
          "userRequest": "./prev-next-button",
          "loc": "17:4-25:16"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 4,
      "source": "// prev/next buttons\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      './flickity',\n      'tap-listener/tap-listener',\n      'fizzy-ui-utils/utils'\n    ], function( Flickity, TapListener, utils ) {\n      return factory( window, Flickity, TapListener, utils );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('./flickity'),\n      require('tap-listener'),\n      require('fizzy-ui-utils')\n    );\n  } else {\n    // browser global\n    factory(\n      window,\n      window.Flickity,\n      window.TapListener,\n      window.fizzyUIUtils\n    );\n  }\n\n}( window, function factory( window, Flickity, TapListener, utils ) {\n'use strict';\n\nvar svgURI = 'http://www.w3.org/2000/svg';\n\n// -------------------------- PrevNextButton -------------------------- //\n\nfunction PrevNextButton( direction, parent ) {\n  this.direction = direction;\n  this.parent = parent;\n  this._create();\n}\n\nPrevNextButton.prototype = new TapListener();\n\nPrevNextButton.prototype._create = function() {\n  // properties\n  this.isEnabled = true;\n  this.isPrevious = this.direction == -1;\n  var leftDirection = this.parent.options.rightToLeft ? 1 : -1;\n  this.isLeft = this.direction == leftDirection;\n\n  var element = this.element = document.createElement('button');\n  element.className = 'flickity-prev-next-button';\n  element.className += this.isPrevious ? ' previous' : ' next';\n  // prevent button from submitting form http://stackoverflow.com/a/10836076/182183\n  element.setAttribute( 'type', 'button' );\n  // init as disabled\n  this.disable();\n\n  element.setAttribute( 'aria-label', this.isPrevious ? 'previous' : 'next' );\n\n  // create arrow\n  var svg = this.createSVG();\n  element.appendChild( svg );\n  // events\n  this.on( 'tap', this.onTap );\n  this.parent.on( 'select', this.update.bind( this ) );\n  this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );\n};\n\nPrevNextButton.prototype.activate = function() {\n  this.bindTap( this.element );\n  // click events from keyboard\n  this.element.addEventListener( 'click', this );\n  // add to DOM\n  this.parent.element.appendChild( this.element );\n};\n\nPrevNextButton.prototype.deactivate = function() {\n  // remove from DOM\n  this.parent.element.removeChild( this.element );\n  // do regular TapListener destroy\n  TapListener.prototype.destroy.call( this );\n  // click events from keyboard\n  this.element.removeEventListener( 'click', this );\n};\n\nPrevNextButton.prototype.createSVG = function() {\n  var svg = document.createElementNS( svgURI, 'svg');\n  svg.setAttribute( 'viewBox', '0 0 100 100' );\n  var path = document.createElementNS( svgURI, 'path');\n  var pathMovements = getArrowMovements( this.parent.options.arrowShape );\n  path.setAttribute( 'd', pathMovements );\n  path.setAttribute( 'class', 'arrow' );\n  // rotate arrow\n  if ( !this.isLeft ) {\n    path.setAttribute( 'transform', 'translate(100, 100) rotate(180) ' );\n  }\n  svg.appendChild( path );\n  return svg;\n};\n\n// get SVG path movmement\nfunction getArrowMovements( shape ) {\n  // use shape as movement if string\n  if ( typeof shape == 'string' ) {\n    return shape;\n  }\n  // create movement string\n  return 'M ' + shape.x0 + ',50' +\n    ' L ' + shape.x1 + ',' + ( shape.y1 + 50 ) +\n    ' L ' + shape.x2 + ',' + ( shape.y2 + 50 ) +\n    ' L ' + shape.x3 + ',50 ' +\n    ' L ' + shape.x2 + ',' + ( 50 - shape.y2 ) +\n    ' L ' + shape.x1 + ',' + ( 50 - shape.y1 ) +\n    ' Z';\n}\n\nPrevNextButton.prototype.onTap = function() {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this.parent.uiChange();\n  var method = this.isPrevious ? 'previous' : 'next';\n  this.parent[ method ]();\n};\n\nPrevNextButton.prototype.handleEvent = utils.handleEvent;\n\nPrevNextButton.prototype.onclick = function() {\n  // only allow clicks from keyboard\n  var focused = document.activeElement;\n  if ( focused && focused == this.element ) {\n    this.onTap();\n  }\n};\n\n// -----  ----- //\n\nPrevNextButton.prototype.enable = function() {\n  if ( this.isEnabled ) {\n    return;\n  }\n  this.element.disabled = false;\n  this.isEnabled = true;\n};\n\nPrevNextButton.prototype.disable = function() {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this.element.disabled = true;\n  this.isEnabled = false;\n};\n\nPrevNextButton.prototype.update = function() {\n  // index of first or last slide, if previous or next\n  var slides = this.parent.slides;\n  // enable is wrapAround and at least 2 slides\n  if ( this.parent.options.wrapAround && slides.length > 1 ) {\n    this.enable();\n    return;\n  }\n  var lastIndex = slides.length ? slides.length - 1 : 0;\n  var boundIndex = this.isPrevious ? 0 : lastIndex;\n  var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';\n  this[ method ]();\n};\n\nPrevNextButton.prototype.destroy = function() {\n  this.deactivate();\n};\n\n// -------------------------- Flickity prototype -------------------------- //\n\nutils.extend( Flickity.defaults, {\n  prevNextButtons: true,\n  arrowShape: {\n    x0: 10,\n    x1: 60, y1: 50,\n    x2: 70, y2: 40,\n    x3: 30\n  }\n});\n\nFlickity.createMethods.push('_createPrevNextButtons');\nvar proto = Flickity.prototype;\n\nproto._createPrevNextButtons = function() {\n  if ( !this.options.prevNextButtons ) {\n    return;\n  }\n\n  this.prevButton = new PrevNextButton( -1, this );\n  this.nextButton = new PrevNextButton( 1, this );\n\n  this.on( 'activate', this.activatePrevNextButtons );\n};\n\nproto.activatePrevNextButtons = function() {\n  this.prevButton.activate();\n  this.nextButton.activate();\n  this.on( 'deactivate', this.deactivatePrevNextButtons );\n};\n\nproto.deactivatePrevNextButtons = function() {\n  this.prevButton.deactivate();\n  this.nextButton.deactivate();\n  this.off( 'deactivate', this.deactivatePrevNextButtons );\n};\n\n// --------------------------  -------------------------- //\n\nFlickity.PrevNextButton = PrevNextButton;\n\nreturn Flickity;\n\n}));\n"
    },
    {
      "id": 31,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/slide.js",
      "name": "./~/flickity/js/slide.js",
      "index": 27,
      "index2": 22,
      "size": 1935,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
      "issuerId": 1,
      "issuerName": "./~/flickity/js/flickity.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 1,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/flickity.js",
          "module": "./~/flickity/js/flickity.js",
          "moduleName": "./~/flickity/js/flickity.js",
          "type": "amd require",
          "userRequest": "./slide",
          "loc": "7:4-16:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "// slide\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.Slide = factory();\n  }\n\n}( window, function factory() {\n'use strict';\n\nfunction Slide( parent ) {\n  this.parent = parent;\n  this.isOriginLeft = parent.originSide == 'left';\n  this.cells = [];\n  this.outerWidth = 0;\n  this.height = 0;\n}\n\nvar proto = Slide.prototype;\n\nproto.addCell = function( cell ) {\n  this.cells.push( cell );\n  this.outerWidth += cell.size.outerWidth;\n  this.height = Math.max( cell.size.outerHeight, this.height );\n  // first cell stuff\n  if ( this.cells.length == 1 ) {\n    this.x = cell.x; // x comes from first cell\n    var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';\n    this.firstMargin = cell.size[ beginMargin ];\n  }\n};\n\nproto.updateTarget = function() {\n  var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';\n  var lastCell = this.getLastCell();\n  var lastMargin = lastCell ? lastCell.size[ endMargin ] : 0;\n  var slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );\n  this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;\n};\n\nproto.getLastCell = function() {\n  return this.cells[ this.cells.length - 1 ];\n};\n\nproto.select = function() {\n  this.changeSelectedClass('add');\n};\n\nproto.unselect = function() {\n  this.changeSelectedClass('remove');\n};\n\nproto.changeSelectedClass = function( method ) {\n  this.cells.forEach( function( cell ) {\n    cell.element.classList[ method ]('is-selected');\n  });\n};\n\nproto.getCellElements = function() {\n  return this.cells.map( function( cell ) {\n    return cell.element;\n  });\n};\n\nreturn Slide;\n\n}));\n"
    },
    {
      "id": 32,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/is-arrayish/index.js",
      "name": "./~/is-arrayish/index.js",
      "index": 15,
      "index2": 9,
      "size": 333,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/simple-swizzle/index.js",
      "issuerId": 36,
      "issuerName": "./~/simple-swizzle/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 36,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/simple-swizzle/index.js",
          "module": "./~/simple-swizzle/index.js",
          "moduleName": "./~/simple-swizzle/index.js",
          "type": "cjs require",
          "userRequest": "is-arrayish",
          "loc": "3:17-39"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 6,
      "source": "'use strict';\n\nmodule.exports = function isArrayish(obj) {\n\tif (!obj || typeof obj === 'string') {\n\t\treturn false;\n\t}\n\n\treturn obj instanceof Array || Array.isArray(obj) ||\n\t\t(obj.length >= 0 && (obj.splice instanceof Function ||\n\t\t\t(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));\n};\n"
    },
    {
      "id": 33,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/preact/dist/preact.js",
      "name": "./~/preact/dist/preact.js",
      "index": 2,
      "index2": 0,
      "size": 23349,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/preact/devtools.js",
      "issuerId": 3,
      "issuerName": "./~/preact/devtools.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 3,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/preact/devtools.js",
          "module": "./~/preact/devtools.js",
          "moduleName": "./~/preact/devtools.js",
          "type": "cjs require",
          "userRequest": "preact",
          "loc": "2:73-90"
        },
        {
          "moduleId": 10,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/find-us.js",
          "module": "./_js/find-us.js",
          "moduleName": "./_js/find-us.js",
          "type": "cjs require",
          "userRequest": "preact",
          "loc": "3:14-31"
        },
        {
          "moduleId": 39,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/components/Ad.js",
          "module": "./_js/components/Ad.js",
          "moduleName": "./_js/components/Ad.js",
          "type": "cjs require",
          "userRequest": "preact",
          "loc": "9:14-31"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 2,
      "source": "!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function h(nodeName, attributes) {\n        var lastSimple, child, simple, i, children = [];\n        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);\n        if (attributes && attributes.children) {\n            if (!stack.length) stack.push(attributes.children);\n            delete attributes.children;\n        }\n        while (stack.length) if ((child = stack.pop()) instanceof Array) for (i = child.length; i--; ) stack.push(child[i]); else if (null != child && child !== !1) {\n            if ('number' == typeof child || child === !0) child = String(child);\n            simple = 'string' == typeof child;\n            if (simple && lastSimple) children[children.length - 1] += child; else {\n                children.push(child);\n                lastSimple = simple;\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.');\n        return function(e) {\n            var t = e && e.target || this, state = {}, obj = state, v = isString(eventPath) ? delve(e, eventPath) : t.nodeName ? t.type.match(/^che|rad/) ? t.checked : t.value : e, i = 0;\n            for (;i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = !i && component.state[path[i]] || {});\n            obj[path[i]] = v;\n            component.setState(state);\n        };\n    }\n    function enqueueRender(component) {\n        if (!component._dirty && (component._dirty = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        var p, list = items;\n        items = [];\n        while (p = list.pop()) if (p._dirty) renderComponent(p);\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return node instanceof Text;\n        if (isString(vnode.nodeName)) return !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return (node._componentConstructor ? node._componentConstructor === vnode.nodeName : !0) || isFunctionalComponent(vnode); else ;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var props = clone(vnode.attributes);\n        props.children = vnode.children;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];\n        return props;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, old, value, isSvg) {\n        if ('className' === name) name = 'class';\n        if ('class' === name && value && 'object' == typeof value) value = hashToClassName(value);\n        if ('key' === name) ; else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) node.innerHTML = value && value.__html || ''; else if ('o' == name[0] && 'n' == name[1]) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            } else if (l[name]) node.removeEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            l[name] = value;\n        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {\n            setProperty(node, name, null == value ? '' : value);\n            if (null == value || value === !1) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (null == value || value === !1) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function collectNode(node) {\n        removeNode(node);\n        if (node instanceof Element) {\n            node._component = node._componentConstructor = null;\n            var _name = node.normalizedNodeName || toLowerCase(node.nodeName);\n            (nodes[_name] || (nodes[_name] = [])).push(node);\n        }\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) {\n            if (options.afterMount) options.afterMount(c);\n            if (c.componentDidMount) c.componentDidMount();\n        }\n    }\n    function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n        if (!diffLevel++) {\n            isSvgMode = parent instanceof SVGElement;\n            hydrating = dom && !(ATTR_KEY in dom);\n        }\n        var ret = idiff(dom, vnode, context, mountAll);\n        if (parent && ret.parentNode !== parent) parent.appendChild(ret);\n        if (!--diffLevel) {\n            hydrating = !1;\n            if (!componentRoot) flushMounts();\n        }\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll) {\n        var originalAttributes = vnode && vnode.attributes;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (null == vnode) vnode = '';\n        if (isString(vnode)) {\n            if (dom && dom instanceof Text) {\n                if (dom.nodeValue != vnode) dom.nodeValue = vnode;\n            } else {\n                if (dom) recollectNodeTree(dom);\n                dom = document.createTextNode(vnode);\n            }\n            dom[ATTR_KEY] = !0;\n            return dom;\n        }\n        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        var out = dom, nodeName = String(vnode.nodeName), prevSvgMode = isSvgMode, vchildren = vnode.children;\n        isSvgMode = 'svg' === nodeName ? !0 : 'foreignObject' === nodeName ? !1 : isSvgMode;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n            recollectNodeTree(dom);\n        }\n        var fc = out.firstChild, props = out[ATTR_KEY];\n        if (!props) {\n            out[ATTR_KEY] = props = {};\n            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;\n        }\n        diffAttributes(out, vnode.attributes, props);\n        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && fc && fc instanceof Text && !fc.nextSibling) {\n            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];\n        } else if (vchildren && vchildren.length || fc) innerDiffNode(out, vchildren, context, mountAll);\n        if (originalAttributes && 'function' == typeof originalAttributes.ref) (props.ref = originalAttributes.ref)(out);\n        isSvgMode = prevSvgMode;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], props = _child[ATTR_KEY], key = vlen ? (c = _child._component) ? c.__key : props ? props.key : null : null;\n            if (null != key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else if (hydrating || props) children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            var key = vchild.key;\n            if (null != key) {\n                if (keyedLen && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child && child !== dom) if (i >= len) dom.appendChild(child); else if (child !== originalChildren[i]) {\n                if (child === originalChildren[i + 1]) removeNode(originalChildren[i]);\n                dom.insertBefore(child, originalChildren[i] || null);\n            }\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) recollectNodeTree(keyed[i]);\n        while (min <= childrenLen) {\n            child = children[childrenLen--];\n            if (child) recollectNodeTree(child);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            var c;\n            while (c = node.lastChild) recollectNodeTree(c, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs, old) {\n        for (var _name in old) if (!(attrs && _name in attrs) && null != old[_name]) setAccessor(dom, _name, old[_name], old[_name] = void 0, isSvgMode);\n        if (attrs) for (var _name2 in attrs) if (!('children' === _name2 || 'innerHTML' === _name2 || _name2 in old && attrs[_name2] === ('value' === _name2 || 'checked' === _name2 ? dom[_name2] : old[_name2]))) setAccessor(dom, _name2, old[_name2], old[_name2] = attrs[_name2], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        Component.call(inst, props, context);\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        if (!component._disable) {\n            component._disable = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (!component.base || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disable = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll, isChild) {\n        if (!component._disable) {\n            var skip, rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent)) {\n                    var childProps = getNodeProps(rendered);\n                    inst = initialChildComponent;\n                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst.nextBase = inst.nextBase || nextBase;\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1, mountAll, !0);\n                    }\n                    base = inst.base;\n                } else {\n                    cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);\n                    }\n                }\n                if (initialBase && base !== initialBase && inst !== initialChildComponent) {\n                    var baseParent = initialBase.parentNode;\n                    if (baseParent && base !== baseParent) {\n                        baseParent.replaceChild(base, initialBase);\n                        if (!toUnmount) {\n                            initialBase._component = null;\n                            recollectNodeTree(initialBase);\n                        }\n                    }\n                }\n                if (toUnmount) unmountComponent(toUnmount, base !== initialBase);\n                component.base = base;\n                if (base && !isChild) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) (componentRef = t).base = base;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {\n                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n                if (options.afterUpdate) options.afterUpdate(component);\n            }\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            if (!diffLevel && !isChild) flushMounts();\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (c && isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (c && !isDirectOwner) {\n                unmountComponent(c, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) {\n                c.nextBase = dom;\n                oldDom = null;\n            }\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        if (options.beforeUnmount) options.beforeUnmount(component);\n        var base = component.base;\n        component._disable = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            var c;\n            while (c = base.lastChild) recollectNodeTree(c, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this.context = context;\n        this.props = props;\n        if (!this.state) this.state = {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var options = {};\n    var stack = [];\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var NON_BUBBLING_EVENTS = {\n        blur: 1,\n        error: 1,\n        focus: 1,\n        load: 1,\n        resize: 1,\n        scroll: 1\n    };\n    var items = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var hydrating = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {});\n            return c[key + eventPath] || (c[key + eventPath] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            enqueueRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {}\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map"
    },
    {
      "id": 35,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/scrollreveal/dist/scrollreveal.js",
      "name": "./~/scrollreveal/dist/scrollreveal.js",
      "index": 8,
      "index2": 5,
      "size": 27029,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/food.js",
      "issuerId": 11,
      "issuerName": "./_js/food.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 11,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/food.js",
          "module": "./_js/food.js",
          "moduleName": "./_js/food.js",
          "type": "cjs require",
          "userRequest": "scrollreveal",
          "loc": "3:20-43"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////             /////    /////\n/////             /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n         /////    /////\n         /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n/////    /////    /////    /////\n\n/**\n * ScrollReveal\n * ------------\n * Version : 3.3.2\n * Website : scrollrevealjs.org\n * Repo    : github.com/jlmakes/scrollreveal.js\n * Author  : Julian Lloyd (@jlmakes)\n */\n\n;(function () {\n  'use strict'\n\n  var sr\n  var _requestAnimationFrame\n\n  function ScrollReveal (config) {\n    // Support instantiation without the `new` keyword.\n    if (typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype) {\n      return new ScrollReveal(config)\n    }\n\n    sr = this // Save reference to instance.\n    sr.version = '3.3.2'\n    sr.tools = new Tools() // *required utilities\n\n    if (sr.isSupported()) {\n      sr.tools.extend(sr.defaults, config || {})\n\n      sr.defaults.container = _resolveContainer(sr.defaults)\n\n      sr.store = {\n        elements: {},\n        containers: []\n      }\n\n      sr.sequences = {}\n      sr.history = []\n      sr.uid = 0\n      sr.initialized = false\n    } else if (typeof console !== 'undefined' && console !== null) {\n      // Note: IE9 only supports console if devtools are open.\n      console.log('ScrollReveal is not supported in this browser.')\n    }\n\n    return sr\n  }\n\n  /**\n   * Configuration\n   * -------------\n   * This object signature can be passed directly to the ScrollReveal constructor,\n   * or as the second argument of the `reveal()` method.\n   */\n\n  ScrollReveal.prototype.defaults = {\n    // 'bottom', 'left', 'top', 'right'\n    origin: 'bottom',\n\n    // Can be any valid CSS distance, e.g. '5rem', '10%', '20vw', etc.\n    distance: '20px',\n\n    // Time in milliseconds.\n    duration: 500,\n    delay: 0,\n\n    // Starting angles in degrees, will transition from these values to 0 in all axes.\n    rotate: { x: 0, y: 0, z: 0 },\n\n    // Starting opacity value, before transitioning to the computed opacity.\n    opacity: 0,\n\n    // Starting scale value, will transition from this value to 1\n    scale: 0.9,\n\n    // Accepts any valid CSS easing, e.g. 'ease', 'ease-in-out', 'linear', etc.\n    easing: 'cubic-bezier(0.6, 0.2, 0.1, 1)',\n\n    // `<html>` is the default reveal container. You can pass either:\n    // DOM Node, e.g. document.querySelector('.fooContainer')\n    // Selector, e.g. '.fooContainer'\n    container: window.document.documentElement,\n\n    // true/false to control reveal animations on mobile.\n    mobile: true,\n\n    // true:  reveals occur every time elements become visible\n    // false: reveals occur once as elements become visible\n    reset: false,\n\n    // 'always' — delay for all reveal animations\n    // 'once'   — delay only the first time reveals occur\n    // 'onload' - delay only for animations triggered by first load\n    useDelay: 'always',\n\n    // Change when an element is considered in the viewport. The default value\n    // of 0.20 means 20% of an element must be visible for its reveal to occur.\n    viewFactor: 0.2,\n\n    // Pixel values that alter the container boundaries.\n    // e.g. Set `{ top: 48 }`, if you have a 48px tall fixed toolbar.\n    // --\n    // Visual Aid: https://scrollrevealjs.org/assets/viewoffset.png\n    viewOffset: { top: 0, right: 0, bottom: 0, left: 0 },\n\n    // Callbacks that fire for each triggered element reveal, and reset.\n    beforeReveal: function (domEl) {},\n    beforeReset: function (domEl) {},\n\n    // Callbacks that fire for each completed element reveal, and reset.\n    afterReveal: function (domEl) {},\n    afterReset: function (domEl) {}\n  }\n\n  /**\n   * Check if client supports CSS Transform and CSS Transition.\n   * @return {boolean}\n   */\n  ScrollReveal.prototype.isSupported = function () {\n    var style = document.documentElement.style\n    return 'WebkitTransition' in style && 'WebkitTransform' in style ||\n      'transition' in style && 'transform' in style\n  }\n\n  /**\n   * Creates a reveal set, a group of elements that will animate when they\n   * become visible. If [interval] is provided, a new sequence is created\n   * that will ensure elements reveal in the order they appear in the DOM.\n   *\n   * @param {Node|NodeList|string} [target]   The node, node list or selector to use for animation.\n   * @param {Object}               [config]   Override the defaults for this reveal set.\n   * @param {number}               [interval] Time between sequenced element animations (milliseconds).\n   * @param {boolean}              [sync]     Used internally when updating reveals for async content.\n   *\n   * @return {Object} The current ScrollReveal instance.\n   */\n  ScrollReveal.prototype.reveal = function (target, config, interval, sync) {\n    var container\n    var elements\n    var elem\n    var elemId\n    var sequence\n    var sequenceId\n\n    // No custom configuration was passed, but a sequence interval instead.\n    // let’s shuffle things around to make sure everything works.\n    if (config !== undefined && typeof config === 'number') {\n      interval = config\n      config = {}\n    } else if (config === undefined || config === null) {\n      config = {}\n    }\n\n    container = _resolveContainer(config)\n    elements = _getRevealElements(target, container)\n\n    if (!elements.length) {\n      console.log('ScrollReveal: reveal on \"' + target + '\" failed, no elements found.')\n      return sr\n    }\n\n    // Prepare a new sequence if an interval is passed.\n    if (interval && typeof interval === 'number') {\n      sequenceId = _nextUid()\n\n      sequence = sr.sequences[sequenceId] = {\n        id: sequenceId,\n        interval: interval,\n        elemIds: [],\n        active: false\n      }\n    }\n\n    // Begin main loop to configure ScrollReveal elements.\n    for (var i = 0; i < elements.length; i++) {\n      // Check if the element has already been configured and grab it from the store.\n      elemId = elements[i].getAttribute('data-sr-id')\n      if (elemId) {\n        elem = sr.store.elements[elemId]\n      } else {\n        // Otherwise, let’s do some basic setup.\n        elem = {\n          id: _nextUid(),\n          domEl: elements[i],\n          seen: false,\n          revealing: false\n        }\n        elem.domEl.setAttribute('data-sr-id', elem.id)\n      }\n\n      // Sequence only setup\n      if (sequence) {\n        elem.sequence = {\n          id: sequence.id,\n          index: sequence.elemIds.length\n        }\n\n        sequence.elemIds.push(elem.id)\n      }\n\n      // New or existing element, it’s time to update its configuration, styles,\n      // and send the updates to our store.\n      _configure(elem, config, container)\n      _style(elem)\n      _updateStore(elem)\n\n      // We need to make sure elements are set to visibility: visible, even when\n      // on mobile and `config.mobile === false`, or if unsupported.\n      if (sr.tools.isMobile() && !elem.config.mobile || !sr.isSupported()) {\n        elem.domEl.setAttribute('style', elem.styles.inline)\n        elem.disabled = true\n      } else if (!elem.revealing) {\n        // Otherwise, proceed normally.\n        elem.domEl.setAttribute('style',\n          elem.styles.inline +\n          elem.styles.transform.initial\n        )\n      }\n    }\n\n    // Each `reveal()` is recorded so that when calling `sync()` while working\n    // with asynchronously loaded content, it can re-trace your steps but with\n    // all your new elements now in the DOM.\n\n    // Since `reveal()` is called internally by `sync()`, we don’t want to\n    // record or intiialize each reveal during syncing.\n    if (!sync && sr.isSupported()) {\n      _record(target, config, interval)\n\n      // We push initialization to the event queue using setTimeout, so that we can\n      // give ScrollReveal room to process all reveal calls before putting things into motion.\n      // --\n      // Philip Roberts - What the heck is the event loop anyway? (JSConf EU 2014)\n      // https://www.youtube.com/watch?v=8aGhZQkoFbQ\n      if (sr.initTimeout) {\n        window.clearTimeout(sr.initTimeout)\n      }\n      sr.initTimeout = window.setTimeout(_init, 0)\n    }\n\n    return sr\n  }\n\n  /**\n   * Re-runs `reveal()` for each record stored in history, effectively capturing\n   * any content loaded asynchronously that matches existing reveal set targets.\n   * @return {Object} The current ScrollReveal instance.\n   */\n  ScrollReveal.prototype.sync = function () {\n    if (sr.history.length && sr.isSupported()) {\n      for (var i = 0; i < sr.history.length; i++) {\n        var record = sr.history[i]\n        sr.reveal(record.target, record.config, record.interval, true)\n      }\n      _init()\n    } else {\n      console.log('ScrollReveal: sync failed, no reveals found.')\n    }\n    return sr\n  }\n\n  /**\n   * Private Methods\n   * ---------------\n   */\n\n  function _resolveContainer (config) {\n    if (config && config.container) {\n      if (typeof config.container === 'string') {\n        return window.document.documentElement.querySelector(config.container)\n      } else if (sr.tools.isNode(config.container)) {\n        return config.container\n      } else {\n        console.log('ScrollReveal: invalid container \"' + config.container + '\" provided.')\n        console.log('ScrollReveal: falling back to default container.')\n      }\n    }\n    return sr.defaults.container\n  }\n\n  /**\n   * check to see if a node or node list was passed in as the target,\n   * otherwise query the container using target as a selector.\n   *\n   * @param {Node|NodeList|string} [target]    client input for reveal target.\n   * @param {Node}                 [container] parent element for selector queries.\n   *\n   * @return {array} elements to be revealed.\n   */\n  function _getRevealElements (target, container) {\n    if (typeof target === 'string') {\n      return Array.prototype.slice.call(container.querySelectorAll(target))\n    } else if (sr.tools.isNode(target)) {\n      return [target]\n    } else if (sr.tools.isNodeList(target)) {\n      return Array.prototype.slice.call(target)\n    }\n    return []\n  }\n\n  /**\n   * A consistent way of creating unique IDs.\n   * @returns {number}\n   */\n  function _nextUid () {\n    return ++sr.uid\n  }\n\n  function _configure (elem, config, container) {\n    // If a container was passed as a part of the config object,\n    // let’s overwrite it with the resolved container passed in.\n    if (config.container) config.container = container\n    // If the element hasn’t already been configured, let’s use a clone of the\n    // defaults extended by the configuration passed as the second argument.\n    if (!elem.config) {\n      elem.config = sr.tools.extendClone(sr.defaults, config)\n    } else {\n      // Otherwise, let’s use a clone of the existing element configuration extended\n      // by the configuration passed as the second argument.\n      elem.config = sr.tools.extendClone(elem.config, config)\n    }\n\n    // Infer CSS Transform axis from origin string.\n    if (elem.config.origin === 'top' || elem.config.origin === 'bottom') {\n      elem.config.axis = 'Y'\n    } else {\n      elem.config.axis = 'X'\n    }\n  }\n\n  function _style (elem) {\n    var computed = window.getComputedStyle(elem.domEl)\n\n    if (!elem.styles) {\n      elem.styles = {\n        transition: {},\n        transform: {},\n        computed: {}\n      }\n\n      // Capture any existing inline styles, and add our visibility override.\n      // --\n      // See section 4.2. in the Documentation:\n      // https://github.com/jlmakes/scrollreveal.js#42-improve-user-experience\n      elem.styles.inline = elem.domEl.getAttribute('style') || ''\n      elem.styles.inline += '; visibility: visible; '\n\n      // grab the elements existing opacity.\n      elem.styles.computed.opacity = computed.opacity\n\n      // grab the elements existing transitions.\n      if (!computed.transition || computed.transition === 'all 0s ease 0s') {\n        elem.styles.computed.transition = ''\n      } else {\n        elem.styles.computed.transition = computed.transition + ', '\n      }\n    }\n\n    // Create transition styles\n    elem.styles.transition.instant = _generateTransition(elem, 0)\n    elem.styles.transition.delayed = _generateTransition(elem, elem.config.delay)\n\n    // Generate transform styles, first with the webkit prefix.\n    elem.styles.transform.initial = ' -webkit-transform:'\n    elem.styles.transform.target = ' -webkit-transform:'\n    _generateTransform(elem)\n\n    // And again without any prefix.\n    elem.styles.transform.initial += 'transform:'\n    elem.styles.transform.target += 'transform:'\n    _generateTransform(elem)\n  }\n\n  function _generateTransition (elem, delay) {\n    var config = elem.config\n\n    return '-webkit-transition: ' + elem.styles.computed.transition +\n      '-webkit-transform ' + config.duration / 1000 + 's ' +\n      config.easing + ' ' +\n      delay / 1000 + 's, opacity ' +\n      config.duration / 1000 + 's ' +\n      config.easing + ' ' +\n      delay / 1000 + 's; ' +\n\n      'transition: ' + elem.styles.computed.transition +\n      'transform ' + config.duration / 1000 + 's ' +\n      config.easing + ' ' +\n      delay / 1000 + 's, opacity ' +\n      config.duration / 1000 + 's ' +\n      config.easing + ' ' +\n      delay / 1000 + 's; '\n  }\n\n  function _generateTransform (elem) {\n    var config = elem.config\n    var cssDistance\n    var transform = elem.styles.transform\n\n    // Let’s make sure our our pixel distances are negative for top and left.\n    // e.g. origin = 'top' and distance = '25px' starts at `top: -25px` in CSS.\n    if (config.origin === 'top' || config.origin === 'left') {\n      cssDistance = /^-/.test(config.distance)\n        ? config.distance.substr(1)\n        : '-' + config.distance\n    } else {\n      cssDistance = config.distance\n    }\n\n    if (parseInt(config.distance)) {\n      transform.initial += ' translate' + config.axis + '(' + cssDistance + ')'\n      transform.target += ' translate' + config.axis + '(0)'\n    }\n    if (config.scale) {\n      transform.initial += ' scale(' + config.scale + ')'\n      transform.target += ' scale(1)'\n    }\n    if (config.rotate.x) {\n      transform.initial += ' rotateX(' + config.rotate.x + 'deg)'\n      transform.target += ' rotateX(0)'\n    }\n    if (config.rotate.y) {\n      transform.initial += ' rotateY(' + config.rotate.y + 'deg)'\n      transform.target += ' rotateY(0)'\n    }\n    if (config.rotate.z) {\n      transform.initial += ' rotateZ(' + config.rotate.z + 'deg)'\n      transform.target += ' rotateZ(0)'\n    }\n    transform.initial += '; opacity: ' + config.opacity + ';'\n    transform.target += '; opacity: ' + elem.styles.computed.opacity + ';'\n  }\n\n  function _updateStore (elem) {\n    var container = elem.config.container\n\n    // If this element’s container isn’t already in the store, let’s add it.\n    if (container && sr.store.containers.indexOf(container) === -1) {\n      sr.store.containers.push(elem.config.container)\n    }\n\n    // Update the element stored with our new element.\n    sr.store.elements[elem.id] = elem\n  }\n\n  function _record (target, config, interval) {\n    // Save the `reveal()` arguments that triggered this `_record()` call, so we\n    // can re-trace our steps when calling the `sync()` method.\n    var record = {\n      target: target,\n      config: config,\n      interval: interval\n    }\n    sr.history.push(record)\n  }\n\n  function _init () {\n    if (sr.isSupported()) {\n      // Initial animate call triggers valid reveal animations on first load.\n      // Subsequent animate calls are made inside the event handler.\n      _animate()\n\n      // Then we loop through all container nodes in the store and bind event\n      // listeners to each.\n      for (var i = 0; i < sr.store.containers.length; i++) {\n        sr.store.containers[i].addEventListener('scroll', _handler)\n        sr.store.containers[i].addEventListener('resize', _handler)\n      }\n\n      // Let’s also do a one-time binding of window event listeners.\n      if (!sr.initialized) {\n        window.addEventListener('scroll', _handler)\n        window.addEventListener('resize', _handler)\n        sr.initialized = true\n      }\n    }\n    return sr\n  }\n\n  function _handler () {\n    _requestAnimationFrame(_animate)\n  }\n\n  function _setActiveSequences () {\n    var active\n    var elem\n    var elemId\n    var sequence\n\n    // Loop through all sequences\n    sr.tools.forOwn(sr.sequences, function (sequenceId) {\n      sequence = sr.sequences[sequenceId]\n      active = false\n\n      // For each sequenced elemenet, let’s check visibility and if\n      // any are visible, set it’s sequence to active.\n      for (var i = 0; i < sequence.elemIds.length; i++) {\n        elemId = sequence.elemIds[i]\n        elem = sr.store.elements[elemId]\n        if (_isElemVisible(elem) && !active) {\n          active = true\n        }\n      }\n\n      sequence.active = active\n    })\n  }\n\n  function _animate () {\n    var delayed\n    var elem\n\n    _setActiveSequences()\n\n    // Loop through all elements in the store\n    sr.tools.forOwn(sr.store.elements, function (elemId) {\n      elem = sr.store.elements[elemId]\n      delayed = _shouldUseDelay(elem)\n\n      // Let’s see if we should revealand if so,\n      // trigger the `beforeReveal` callback and\n      // determine whether or not to use delay.\n      if (_shouldReveal(elem)) {\n        elem.config.beforeReveal(elem.domEl)\n        if (delayed) {\n          elem.domEl.setAttribute('style',\n            elem.styles.inline +\n            elem.styles.transform.target +\n            elem.styles.transition.delayed\n          )\n        } else {\n          elem.domEl.setAttribute('style',\n            elem.styles.inline +\n            elem.styles.transform.target +\n            elem.styles.transition.instant\n          )\n        }\n\n        // Let’s queue the `afterReveal` callback\n        // and mark the element as seen and revealing.\n        _queueCallback('reveal', elem, delayed)\n        elem.revealing = true\n        elem.seen = true\n\n        if (elem.sequence) {\n          _queueNextInSequence(elem, delayed)\n        }\n      } else if (_shouldReset(elem)) {\n        //Otherwise reset our element and\n        // trigger the `beforeReset` callback.\n        elem.config.beforeReset(elem.domEl)\n        elem.domEl.setAttribute('style',\n          elem.styles.inline +\n          elem.styles.transform.initial +\n          elem.styles.transition.instant\n        )\n        // And queue the `afterReset` callback.\n        _queueCallback('reset', elem)\n        elem.revealing = false\n      }\n    })\n  }\n\n  function _queueNextInSequence (elem, delayed) {\n    var elapsed = 0\n    var delay = 0\n    var sequence = sr.sequences[elem.sequence.id]\n\n    // We’re processing a sequenced element, so let's block other elements in this sequence.\n    sequence.blocked = true\n\n    // Since we’re triggering animations a part of a sequence after animations on first load,\n    // we need to check for that condition and explicitly add the delay to our timer.\n    if (delayed && elem.config.useDelay === 'onload') {\n      delay = elem.config.delay\n    }\n\n    // If a sequence timer is already running, capture the elapsed time and clear it.\n    if (elem.sequence.timer) {\n      elapsed = Math.abs(elem.sequence.timer.started - new Date())\n      window.clearTimeout(elem.sequence.timer)\n    }\n\n    // Start a new timer.\n    elem.sequence.timer = { started: new Date() }\n    elem.sequence.timer.clock = window.setTimeout(function () {\n      // Sequence interval has passed, so unblock the sequence and re-run the handler.\n      sequence.blocked = false\n      elem.sequence.timer = null\n      _handler()\n    }, Math.abs(sequence.interval) + delay - elapsed)\n  }\n\n  function _queueCallback (type, elem, delayed) {\n    var elapsed = 0\n    var duration = 0\n    var callback = 'after'\n\n    // Check which callback we’re working with.\n    switch (type) {\n      case 'reveal':\n        duration = elem.config.duration\n        if (delayed) {\n          duration += elem.config.delay\n        }\n        callback += 'Reveal'\n        break\n\n      case 'reset':\n        duration = elem.config.duration\n        callback += 'Reset'\n        break\n    }\n\n    // If a timer is already running, capture the elapsed time and clear it.\n    if (elem.timer) {\n      elapsed = Math.abs(elem.timer.started - new Date())\n      window.clearTimeout(elem.timer.clock)\n    }\n\n    // Start a new timer.\n    elem.timer = { started: new Date() }\n    elem.timer.clock = window.setTimeout(function () {\n      // The timer completed, so let’s fire the callback and null the timer.\n      elem.config[callback](elem.domEl)\n      elem.timer = null\n    }, duration - elapsed)\n  }\n\n  function _shouldReveal (elem) {\n    if (elem.sequence) {\n      var sequence = sr.sequences[elem.sequence.id]\n      return sequence.active &&\n        !sequence.blocked &&\n        !elem.revealing &&\n        !elem.disabled\n    }\n    return _isElemVisible(elem) &&\n      !elem.revealing &&\n      !elem.disabled\n  }\n\n  function _shouldUseDelay (elem) {\n    var config = elem.config.useDelay\n    return config === 'always' ||\n      (config === 'onload' && !sr.initialized) ||\n      (config === 'once' && !elem.seen)\n  }\n\n  function _shouldReset (elem) {\n    if (elem.sequence) {\n      var sequence = sr.sequences[elem.sequence.id]\n      return !sequence.active &&\n        elem.config.reset &&\n        elem.revealing &&\n        !elem.disabled\n    }\n    return !_isElemVisible(elem) &&\n      elem.config.reset &&\n      elem.revealing &&\n      !elem.disabled\n  }\n\n  function _getContainer (container) {\n    return {\n      width: container.clientWidth,\n      height: container.clientHeight\n    }\n  }\n\n  function _getScrolled (container) {\n    // Return the container scroll values, plus the its offset.\n    if (container && container !== window.document.documentElement) {\n      var offset = _getOffset(container)\n      return {\n        x: container.scrollLeft + offset.left,\n        y: container.scrollTop + offset.top\n      }\n    } else {\n      // Otherwise, default to the window object’s scroll values.\n      return {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      }\n    }\n  }\n\n  function _getOffset (domEl) {\n    var offsetTop = 0\n    var offsetLeft = 0\n\n      // Grab the element’s dimensions.\n    var offsetHeight = domEl.offsetHeight\n    var offsetWidth = domEl.offsetWidth\n\n    // Now calculate the distance between the element and its parent, then\n    // again for the parent to its parent, and again etc... until we have the\n    // total distance of the element to the document’s top and left origin.\n    do {\n      if (!isNaN(domEl.offsetTop)) {\n        offsetTop += domEl.offsetTop\n      }\n      if (!isNaN(domEl.offsetLeft)) {\n        offsetLeft += domEl.offsetLeft\n      }\n      domEl = domEl.offsetParent\n    } while (domEl)\n\n    return {\n      top: offsetTop,\n      left: offsetLeft,\n      height: offsetHeight,\n      width: offsetWidth\n    }\n  }\n\n  function _isElemVisible (elem) {\n    var offset = _getOffset(elem.domEl)\n    var container = _getContainer(elem.config.container)\n    var scrolled = _getScrolled(elem.config.container)\n    var vF = elem.config.viewFactor\n\n      // Define the element geometry.\n    var elemHeight = offset.height\n    var elemWidth = offset.width\n    var elemTop = offset.top\n    var elemLeft = offset.left\n    var elemBottom = elemTop + elemHeight\n    var elemRight = elemLeft + elemWidth\n\n    return confirmBounds() || isPositionFixed()\n\n    function confirmBounds () {\n      // Define the element’s functional boundaries using its view factor.\n      var top = elemTop + elemHeight * vF\n      var left = elemLeft + elemWidth * vF\n      var bottom = elemBottom - elemHeight * vF\n      var right = elemRight - elemWidth * vF\n\n      // Define the container functional boundaries using its view offset.\n      var viewTop = scrolled.y + elem.config.viewOffset.top\n      var viewLeft = scrolled.x + elem.config.viewOffset.left\n      var viewBottom = scrolled.y - elem.config.viewOffset.bottom + container.height\n      var viewRight = scrolled.x - elem.config.viewOffset.right + container.width\n\n      return top < viewBottom &&\n        bottom > viewTop &&\n        left > viewLeft &&\n        right < viewRight\n    }\n\n    function isPositionFixed () {\n      return (window.getComputedStyle(elem.domEl).position === 'fixed')\n    }\n  }\n\n  /**\n   * Utilities\n   * ---------\n   */\n\n  function Tools () {}\n\n  Tools.prototype.isObject = function (object) {\n    return object !== null && typeof object === 'object' && object.constructor === Object\n  }\n\n  Tools.prototype.isNode = function (object) {\n    return typeof window.Node === 'object'\n      ? object instanceof window.Node\n      : object && typeof object === 'object' &&\n        typeof object.nodeType === 'number' &&\n        typeof object.nodeName === 'string'\n  }\n\n  Tools.prototype.isNodeList = function (object) {\n    var prototypeToString = Object.prototype.toString.call(object)\n    var regex = /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n\n    return typeof window.NodeList === 'object'\n      ? object instanceof window.NodeList\n      : object && typeof object === 'object' &&\n        regex.test(prototypeToString) &&\n        typeof object.length === 'number' &&\n        (object.length === 0 || this.isNode(object[0]))\n  }\n\n  Tools.prototype.forOwn = function (object, callback) {\n    if (!this.isObject(object)) {\n      throw new TypeError('Expected \"object\", but received \"' + typeof object + '\".')\n    } else {\n      for (var property in object) {\n        if (object.hasOwnProperty(property)) {\n          callback(property)\n        }\n      }\n    }\n  }\n\n  Tools.prototype.extend = function (target, source) {\n    this.forOwn(source, function (property) {\n      if (this.isObject(source[property])) {\n        if (!target[property] || !this.isObject(target[property])) {\n          target[property] = {}\n        }\n        this.extend(target[property], source[property])\n      } else {\n        target[property] = source[property]\n      }\n    }.bind(this))\n    return target\n  }\n\n  Tools.prototype.extendClone = function (target, source) {\n    return this.extend(this.extend({}, target), source)\n  }\n\n  Tools.prototype.isMobile = function () {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)\n  }\n\n  /**\n   * Polyfills\n   * --------\n   */\n\n  _requestAnimationFrame = window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    function (callback) {\n      window.setTimeout(callback, 1000 / 60)\n    }\n\n  /**\n   * Module Wrapper\n   * --------------\n   */\n  if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n    define(function () {\n      return ScrollReveal\n    })\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ScrollReveal\n  } else {\n    window.ScrollReveal = ScrollReveal\n  }\n}())\n"
    },
    {
      "id": 36,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/simple-swizzle/index.js",
      "name": "./~/simple-swizzle/index.js",
      "index": 14,
      "index2": 10,
      "size": 571,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/color-string/index.js",
      "issuerId": 19,
      "issuerName": "./~/color-string/index.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 19,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/color-string/index.js",
          "module": "./~/color-string/index.js",
          "moduleName": "./~/color-string/index.js",
          "type": "cjs require",
          "userRequest": "simple-swizzle",
          "loc": "3:14-39"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "'use strict';\n\nvar isArrayish = require('is-arrayish');\n\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\n\nvar swizzle = module.exports = function swizzle(args) {\n\tvar results = [];\n\n\tfor (var i = 0, len = args.length; i < len; i++) {\n\t\tvar arg = args[i];\n\n\t\tif (isArrayish(arg)) {\n\t\t\t// http://jsperf.com/javascript-array-concat-vs-push/98\n\t\t\tresults = concat.call(results, slice.call(arg));\n\t\t} else {\n\t\t\tresults.push(arg);\n\t\t}\n\t}\n\n\treturn results;\n};\n\nswizzle.wrap = function (fn) {\n\treturn function () {\n\t\treturn fn(swizzle(arguments));\n\t};\n};\n"
    },
    {
      "id": 37,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/unidragger/unidragger.js",
      "name": "./~/unidragger/unidragger.js",
      "index": 30,
      "index2": 26,
      "size": 7220,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/drag.js",
      "issuerId": 25,
      "issuerName": "./~/flickity/js/drag.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 25,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/flickity/js/drag.js",
          "module": "./~/flickity/js/drag.js",
          "moduleName": "./~/flickity/js/drag.js",
          "type": "amd require",
          "userRequest": "unidragger/unidragger",
          "loc": "7:4-13:6"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 5,
      "source": "/*!\n * Unidragger v2.1.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n      'unipointer/unipointer'\n    ], function( Unipointer ) {\n      return factory( window, Unipointer );\n    });\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      window,\n      require('unipointer')\n    );\n  } else {\n    // browser global\n    window.Unidragger = factory(\n      window,\n      window.Unipointer\n    );\n  }\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// -----  ----- //\n\nfunction noop() {}\n\n// -------------------------- Unidragger -------------------------- //\n\nfunction Unidragger() {}\n\n// inherit Unipointer & EvEmitter\nvar proto = Unidragger.prototype = Object.create( Unipointer.prototype );\n\n// ----- bind start ----- //\n\nproto.bindHandles = function() {\n  this._bindHandles( true );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( false );\n};\n\nvar navigator = window.navigator;\n/**\n * works as unbinder, as you can .bindHandles( false ) to unbind\n * @param {Boolean} isBind - will unbind if falsey\n */\nproto._bindHandles = function( isBind ) {\n  // munge isBind, default to true\n  isBind = isBind === undefined ? true : !!isBind;\n  // extra bind logic\n  var binderExtra;\n  if ( navigator.pointerEnabled ) {\n    binderExtra = function( handle ) {\n      // disable scrolling on the element\n      handle.style.touchAction = isBind ? 'none' : '';\n    };\n  } else if ( navigator.msPointerEnabled ) {\n    binderExtra = function( handle ) {\n      // disable scrolling on the element\n      handle.style.msTouchAction = isBind ? 'none' : '';\n    };\n  } else {\n    binderExtra = noop;\n  }\n  // bind each handle\n  var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';\n  for ( var i=0; i < this.handles.length; i++ ) {\n    var handle = this.handles[i];\n    this._bindStartEvent( handle, isBind );\n    binderExtra( handle );\n    handle[ bindMethod ]( 'click', this );\n  }\n};\n\n// ----- start event ----- //\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  // dismiss range sliders\n  if ( event.target.nodeName == 'INPUT' && event.target.type == 'range' ) {\n    // reset pointerDown logic\n    this.isPointerDown = false;\n    delete this.pointerIdentifier;\n    return;\n  }\n\n  this._dragPointerDown( event, pointer );\n  // kludge to blur focused inputs in dragger\n  var focused = document.activeElement;\n  if ( focused && focused.blur ) {\n    focused.blur();\n  }\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// base pointer down logic\nproto._dragPointerDown = function( event, pointer ) {\n  // track to see when dragging starts\n  this.pointerDownPoint = Unipointer.getPointerPoint( pointer );\n\n  var canPreventDefault = this.canPreventDefaultOnPointerDown( event, pointer );\n  if ( canPreventDefault ) {\n    event.preventDefault();\n  }\n};\n\n// overwriteable method so Flickity can prevent for scrolling\nproto.canPreventDefaultOnPointerDown = function( event ) {\n  // prevent default, unless touchstart or <select>\n  return event.target.nodeName != 'SELECT';\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\n// base pointer move logic\nproto._dragPointerMove = function( event, pointer ) {\n  var movePoint = Unipointer.getPointerPoint( pointer );\n  var moveVector = {\n    x: movePoint.x - this.pointerDownPoint.x,\n    y: movePoint.y - this.pointerDownPoint.y\n  };\n  // start drag if pointer has moved far enough to start drag\n  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {\n    this._dragStart( event, pointer );\n  }\n  return moveVector;\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto._dragPointerUp = function( event, pointer ) {\n  if ( this.isDragging ) {\n    this._dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this._staticClick( event, pointer );\n  }\n};\n\n// -------------------------- drag -------------------------- //\n\n// dragStart\nproto._dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  this.dragStartPoint = Unipointer.getPointerPoint( pointer );\n  // prevent clicks\n  this.isPreventingClicks = true;\n\n  this.dragStart( event, pointer );\n};\n\nproto.dragStart = function( event, pointer ) {\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\n// dragMove\nproto._dragMove = function( event, pointer, moveVector ) {\n  // do not drag if not dragging yet\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// dragEnd\nproto._dragEnd = function( event, pointer ) {\n  // set flags\n  this.isDragging = false;\n  // re-enable clicking async\n  setTimeout( function() {\n    delete this.isPreventingClicks;\n  }.bind( this ) );\n\n  this.dragEnd( event, pointer );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// ----- onclick ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) {\n    event.preventDefault();\n  }\n};\n\n// ----- staticClick ----- //\n\n// triggered after pointer down & up with no/tiny movement\nproto._staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  // allow click in <input>s and <textarea>s\n  var nodeName = event.target.nodeName;\n  if ( nodeName == 'INPUT' || nodeName == 'TEXTAREA' ) {\n    event.target.focus();\n  }\n  this.staticClick( event, pointer );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    setTimeout( function() {\n      delete this.isIgnoringMouseUp;\n    }.bind( this ), 400 );\n  }\n};\n\nproto.staticClick = function( event, pointer ) {\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n};\n\n// ----- utils ----- //\n\nUnidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n// -----  ----- //\n\nreturn Unidragger;\n\n}));\n"
    },
    {
      "id": 38,
      "identifier": "multi preact/devtools ./_js/main.js",
      "name": "multi preact/devtools ./_js/main.js",
      "index": 0,
      "index2": 38,
      "size": 40,
      "cacheable": true,
      "built": false,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": null,
      "issuerId": null,
      "issuerName": null,
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [],
      "usedExports": true,
      "providedExports": null,
      "depth": 0
    },
    {
      "id": 39,
      "identifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/components/Ad.js",
      "name": "./_js/components/Ad.js",
      "index": 6,
      "index2": 3,
      "size": 2463,
      "cacheable": true,
      "built": true,
      "optional": false,
      "prefetched": false,
      "chunks": [
        0
      ],
      "assets": [],
      "issuer": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/find-us.js",
      "issuerId": 10,
      "issuerName": "./_js/find-us.js",
      "failed": false,
      "errors": 0,
      "warnings": 0,
      "reasons": [
        {
          "moduleId": 10,
          "moduleIdentifier": "/home/mischka/projects/coyote-grill/node_modules/babel-loader/lib/index.js!/home/mischka/projects/coyote-grill/_js/find-us.js",
          "module": "./_js/find-us.js",
          "moduleName": "./_js/find-us.js",
          "type": "cjs require",
          "userRequest": "./components/Ad.js",
          "loc": "5:10-39"
        }
      ],
      "usedExports": true,
      "providedExports": null,
      "depth": 3,
      "source": "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _preact = require('preact');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Ad = function (_Component) {\n\t_inherits(Ad, _Component);\n\n\tfunction Ad() {\n\t\t_classCallCheck(this, Ad);\n\n\t\tvar _this = _possibleConstructorReturn(this, (Ad.__proto__ || Object.getPrototypeOf(Ad)).call(this));\n\n\t\t_this.state = {\n\t\t\tactive: false\n\t\t};\n\n\t\t_this.handleButtonClick = _this.handleButtonClick.bind(_this);\n\t\treturn _this;\n\t}\n\n\t_createClass(Ad, [{\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\treturn (0, _preact.h)(\n\t\t\t\t'div',\n\t\t\t\t{ className: 'ad-container ' + (this.state.active && 'active') },\n\t\t\t\tthis.state.active ? (0, _preact.h)(\n\t\t\t\t\t'p',\n\t\t\t\t\tnull,\n\t\t\t\t\t'Cake'\n\t\t\t\t) : (0, _preact.h)(\n\t\t\t\t\t'button',\n\t\t\t\t\t{ type: 'button', onClick: this.handleButtonClick },\n\t\t\t\t\t'Login'\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}, {\n\t\tkey: 'handleButtonClick',\n\t\tvalue: function handleButtonClick() {\n\t\t\tthis.setState({ active: true });\n\t\t}\n\t}]);\n\n\treturn Ad;\n}(_preact.Component);\n\nexports.default = Ad;"
    }
  ],
  "filteredModules": 0,
  "children": []
}